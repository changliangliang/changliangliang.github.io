[{"title":"this指向的问题.md","url":"/2021/06/11/this%E6%8C%87%E5%90%91%E7%9A%84%E9%97%AE%E9%A2%98/","content":"this 指向不同对象的原因let data = &#123;    num: 1&#125;\n\n上面的代码执行时，会向下图中展示的那样，先在内存中生成一个对象 &#123;num: 1&#125;，然后将对象的内存地址赋给变量 data。当我们用 data.num 去读取对象的属性时，js 引擎会先从变量 data 解析出对象的地址，然后从相应位置读取 num 属性的值。\n\n再具体一些，对象的属性中存了下面这些内容，其中 value 是属性值，其它的三个叫做属性标志，这里不对它们展开解释，只需知道它们是用来描述属性的一些特性即可。\n[[value]]: 1[[writable]]: true[[enumerable]]: true[[configurable]]: true\n\n\n当对象的属性值是一个函数时，那么它么 value 就不在是一个具体的值，而是函数的地址。\nlet data = &#123;    num: 1,    print: function() &#123;        console.log(this.num)    &#125;&#125;data.print() // 执行结果为 1let print = data.printpirnt() // 执行结果为 undefined\n\n\n通过上面的分析可以知道同一个函数可以赋值给不同对象的属性，也就是说它可以被不同的对象调用，这个对象就成为函数的当前运行环境。当函数内部使用的运行环境中的变量时，它应该指明使用的是哪个运行环境的中的变量，所以引入了 this 关键字，它所代表的就是当前调用函数的对象。\n箭头函数指向箭头函数它没有自己的 this，如果在箭头函数内部使用 this，那么 this 指向与外部正常函数的指向相同，如下面的箭头函数中的 this 与 fun 保持一致。\nfunction fun() &#123;  () =&gt; &#123;console.log(this)&#125;&#125;\n\ncall&#x2F;apply函数调用的过程中 this 会自动指向函数的当前运行环境，这是函数的默认行为，但有的时候这种默认行为并不能很好的满足我们的需求，比如下面使用装饰器的情况：\nlet person = &#123;    name: &quot;chang&quot;,    printName: function() &#123;        console.log(this.name)    &#125;&#125;// 装饰器函数function decorator(fun) &#123;      return function() &#123;        console.log(&quot;添加装饰器&quot;)        fun()     &#125;&#125;person.printName = decorator(person.printName)person.printName()\n\n上面的代码的运行结果如下，给对象 printName 方法添加装饰器后，方法中的 this 的指向出现的变化，所以 name 属性找不到了。\n\nthis 指向出现变化的原因与下面的代码类似，在函数传参的过程中 printName 原有的运行环境丢失了。\nlet fun = person.printName()fun()\n\n将装饰器函数做如下修改后可以解决上面的问题：\n// 装饰器函数function decorator(fun) &#123;      return function() &#123;        console.log(&quot;添加装饰器&quot;)        fun.call(this)    &#125;&#125;// 装饰器函数function decorator(fun) &#123;      return function() &#123;        console.log(&quot;添加装饰器&quot;)        fun.apply(this)    &#125;&#125;\n\ncall 和 apply 是两个内建方法，调用方式分别为 func.apply(this, arguments) 和 func.call(this, ...arguments)，它们两个的作用是一样的，都是给函数传递一个上下文环境并运行该函数。\nlet person = &#123;    name: &quot;chang&quot;&#125;function printName() &#123;    console.log(this.name)&#125;printName.call(person)printName.apply(person)","tags":["javascript"]},{"title":"Spirng基于Java和注解的配置.md","url":"/2023/03/13/Spirng%E5%9F%BA%E4%BA%8EJava%E5%92%8C%E6%B3%A8%E8%A7%A3%E7%9A%84%E9%85%8D%E7%BD%AE/","content":"XML 开启注解支持Spring 用 xml 配置是比较繁琐的，所以 Spring 由提供了另一种配置方法：注解配置。\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;        xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;        xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans        http://www.springframework.org/schema/beans/spring-beans.xsd&quot;        xmlns:context=&quot;http://www.springframework.org/schema/context&quot;        contex:schemaLocation=&quot;http://www.springframework.org/schema/context        http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;      &lt;context:annotation-config/&gt;    &lt;context:component-scan base-package=&quot;com.chang.pojo&quot;/&gt;   &lt;/beans&gt;\n\n\n在 spring 配置文件中引入 context 文件头\nxmlns:context=&quot;http://www.springframework.org/schema/context&quot;contex:schemaLocation=&quot;http://www.springframework.org/schema/contexthttp://www.springframework.org/schema/context/spring-context.xsd&quot;\n\n开启属性注解支持\n&lt;context:annotation-config/&gt;\n\n配置自动扫描路径\n&lt;context:component-scan base-package=&quot;com.chang.pojo&quot;/&gt;\n\n自动扫描可以设置排除策略，而且可以叠加使用。\n&lt;context:component-scan base-package=&quot;com.chang.pojo&quot;&gt;    &lt;exclude-filter type=&quot;&quot; expression=&quot;&quot; /&gt;    &lt;!--     type的值可以为：    assignable: 排除指定类型（expression指定要排除的类）    annotation: 排除特定注解（expression指定要排除的注解）    aspectj:    通过切入点表达式排除（expression指定切入点表达式，只能用包切入点或类切入点）    regex:      通过正则    custom:     自定义排除策略（一般用于框架底层开发）    --&gt;&lt;/context:component-scan&gt;\n\n类似的，还可以自定义包含策略，不过需要使用 use-default-filters 属性关闭默认的扫描策略。\nuse-default-filters=&quot;false&quot;使默认扫描策略失效&lt;context:component-scan base-package=&quot;com.chang.pojo&quot; use-default-filters=&quot;false&quot;&gt;    &lt;include-filter type=&quot;&quot; expression=&quot;&quot; /&gt;    &lt;!--     type的值可以为和排除方式一样    --&gt;&lt;/context:component-scan&gt;\n\n之后创建容器的过程和 xml 配置是一样的。\nClassPathXmlApplicationContext applicationContext = new ClassPathXmlApplicationContext(&quot;classpath:/bean.xml&quot;);Object student = applicationContext.getBean(&quot;student&quot;);System.out.println(student.getClass());\n\n@Configuration到目前为止，Spring 的配置还是逃脱不了在 xml，那么有没有办法直接不使用 xml 呢？答案是有的，Spring 提供了一种完全使用 Java 类替代 xml 的方式。\n首先需要创建一个配置类，然后给他添加一个 @Configuration 注解，这样这个类对 Spring 来说就是一个配置类了，它的作用就类似于前面的 xml 文件。\n@Configurationpublic class RedisConfig &#123;&#125;\n\n相应的，容器的要从 ClassPathXmlApplicationContext 转化为 AnnotationConfigApplicationContext，使用方法大致如下。\npublic static void main(String[] args) &#123;    ApplicationContext ctx = new AnnotationConfigApplicationContext(AppConfig.class);    MyService myService = ctx.getBean(MyService.class);    myService.doStuff();&#125;\n\nAnnotationConfigApplicationContext 容器可以接受 @Configuration 类，@Component 类和带有 JSR-330 元数据注解的类，接收 @Configuration 类时，@Configuration 类本身被注册为 bean，并且该类中所有已声明的 @Bean 方法也被注册 bean，如果接收了 @Component 和 JSR-330 类，它们将注册为 bean。\n可以在开始的时候构建无参数的容器，之后再利用 register 方法对容器进行配置。\npublic static void main(String[] args) &#123;    AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext();    ctx.register(AppConfig.class, OtherConfig.class);    ctx.register(AdditionalConfig.class);    ctx.refresh();    MyService myService = ctx.getBean(MyService.class);    myService.doStuff();&#125;\n\n@ComponentScan该注解的作用是指定需要扫描的包，等同于 xml 配置中的如下内容：\n&lt;context:component-scan base-package=&quot;com.chang.pojo&quot;/&gt;\n\n与 xm 配置类似，@ComponentScan 也可以自定义扫描策略，用到了 @Filter 注解。\n@Configuration@ComponentScan(basePackages = &quot;org.example&quot;,        includeFilters = @Filter(type = FilterType.REGEX, pattern = &quot;.*Stub.*Repository&quot;),        excludeFilters = @Filter(Repository.class))public class AppConfig &#123;    ...&#125;\n\n&lt;beans&gt;    &lt;context:component-scan base-package=&quot;org.example&quot;&gt;        &lt;context:include-filter type=&quot;regex&quot;                expression=&quot;.*Stub.*Repository&quot;/&gt;        &lt;context:exclude-filter type=&quot;annotation&quot;                expression=&quot;org.springframework.stereotype.Repository&quot;/&gt;    &lt;/context:component-scan&gt;&lt;/beans&gt;\n\n@Filter 中的类型有以下几种选择：\n\nFilterType.ANNOTATION：被注解标识的类。\nFilterType.ASSIFNABLE：类的子类或者接口的实现。\nFilterType.ASPECTJ：匹配给定的 Aspectj 表达式的类。\nFilterType.REGEX：类名与给定正则表达式匹配的类。\nFilterType.CUSTOM：自己实现 org.springframework.core.type .TypeFilter 接口。\n\n使用容器的 scan 方法也可以实现类似功能。\npublic static void main(String[] args) &#123;    AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext();    ctx.scan(&quot;com.acme&quot;);    ctx.refresh();    MyService myService = ctx.getBean(MyService.class);&#125;\n\n@ImportResource 注解如果已经有了部分 xml 配置文件，又想使用 Java 注解配置，那么可以使用该注解，它的作用是将 xml 配置导入容器中，不过需要注意的是，xml 的配置优先级要高于其他配置，如果 xml 配置和注解配置中存在了相同 id 的 bean，那么会以 xml 配置为准。\n@Configuration@ImportResource(&quot;classpath:/com/acme/properties-config.xml&quot;)public class AppConfig &#123;    @Value(&quot;$&#123;jdbc.url&#125;&quot;)    private String url;    @Value(&quot;$&#123;jdbc.username&#125;&quot;)    private String username;    @Value(&quot;$&#123;jdbc.password&#125;&quot;)    private String password;    @Bean    public DataSource dataSource() &#123;        return new DriverManagerDataSource(url, username, password);    &#125;&#125;\n\n@Component@Component 注解相当于 spring 配置文件中的 bean 标签，如果扫描路径下的类添加了该注解，那么 Spring 会把它添加到容器中。\n&lt;bean id=&quot;user&quot; class=&quot;User&quot;/&gt;\n\nbean 的默认 id 为类名首字母小写，可以用 @Component 注解的 value 属性自定义类的 id 值。如果 xml 配置文件中配置了相同 id 的 bean，注解配置会被 xml 配置覆盖。\n@Component(value=&quot;UserOne&quot;)public class User &#123;    public String name = &quot;chang&quot;;&#125;\n\n@Component 有三个衍生注解，目的是为了更好的进行分层，目前使用哪一个功能都一样。\n\n@Controller：一般用于 web 层。\n@Service：一般位于 service 层。\n@Repository：一般位于 dao 层。\n\n@scope 注解该注解用于控制 bean 是单实例还是多实例：\n\nsingleton：单实例模式，默认情况下 Spring 会采用该模式创建对象，关闭 Spring 容器时，bean 会被销毁。\nprototype：多例模式，每次创建新的 bean，并且关闭 Spring 容器时，bean 不会被销毁。\n\n@Controller(&quot;user&quot;)@Scope(&quot;prototype&quot;)public class User &#123;    @Value(&quot;chang&quot;)    public String name;&#125;\n\n@Lazy 注解单实例情况下，Spring 会在工厂创建同时创建 bean，配置 @Lazy 注解后，会把 bean 的创建推迟到该 bean 被使用的时候。\n@Required@Required 注解适用于 bean 的属性设置器方法，用于告诉 Spring 该属性必须注入。\npublic class SimpleMovieLister &#123;    private MovieFinder movieFinder;    @Required    public void setMovieFinder(MovieFinder movieFinder) &#123;        this.movieFinder = movieFinder;    &#125;    // ...&#125;\n\n@Autowired可以将 @Autowired 注解应用于构造函数，不过从 Spring Framework 4.3 开始，如果目标 bean 仅定义一个构造函数作为开始，则不再需要在此类构造函数上使用 @Autowired 注解。但是如果有几个构造函数可用，则必须至少注解一个，以告诉容器使用哪个构造函数。\npublic class MovieRecommender &#123;    private final CustomerPreferenceDao customerPreferenceDao;    @Autowired    public MovieRecommender(CustomerPreferenceDao customerPreferenceDao) &#123;        this.customerPreferenceDao = customerPreferenceDao;    &#125;    // ...&#125;\n\n还可以将 @Autowired 注解 应用于“传统”的 setter 方法，在属性设置阶段，进行自动注入。\npublic class SimpleMovieLister &#123;    private MovieFinder movieFinder;    @Autowired    public void setMovieFinder(MovieFinder movieFinder) &#123;        this.movieFinder = movieFinder;    &#125;    // ...&#125;\n\n如果有需要还可以将注解应用于具有任意名称和多个参数的方法、用于字段或者混合使用。\npublic class MovieRecommender &#123;    private MovieCatalog movieCatalog;    private CustomerPreferenceDao customerPreferenceDao;    @Autowired    public void prepare(MovieCatalog movieCatalog,            CustomerPreferenceDao customerPreferenceDao) &#123;        this.movieCatalog = movieCatalog;        this.customerPreferenceDao = customerPreferenceDao;    &#125;    // ...&#125;\n\npublic class MovieRecommender &#123;    private final CustomerPreferenceDao customerPreferenceDao;    @Autowired    private MovieCatalog movieCatalog;    @Autowired    public MovieRecommender(CustomerPreferenceDao customerPreferenceDao) &#123;        this.customerPreferenceDao = customerPreferenceDao;    &#125;    // ...&#125;\n\n可以用于数组、List、Set 和 Map（key 是 String 的情况下），Spring 会进行自动注入，在 Map 中注入时，使用的 key 是 bean 的 id。如果希望在数组和 List 中以某种顺序注入，需要在 bean 上使用 @Order 或 @Priority 注解指明优先级。\npublic class MovieRecommender &#123;    @Autowired    private MovieCatalog[] movieCatalogs;    // ...&#125;\n\npublic class MovieRecommender &#123;    private Set&lt;MovieCatalog&gt; movieCatalogs;    @Autowired    public void setMovieCatalogs(Set&lt;MovieCatalog&gt; movieCatalogs) &#123;        this.movieCatalogs = movieCatalogs;    &#125;    // ...&#125;\n\npublic class MovieRecommender &#123;    private Map&lt;String, MovieCatalog&gt; movieCatalogs;    @Autowired    public void setMovieCatalogs(Map&lt;String, MovieCatalog&gt; movieCatalogs) &#123;        this.movieCatalogs = movieCatalogs;    &#125;    // ...&#125;\n\n默认情况下，如果没有候选的 bean 可用，自动装配就会失败。默认行为是将带注解的方法，构造函数和字段视为指示必须的依赖项，通过 required 字段可以修改这一默认行为。\npublic class SimpleMovieLister &#123;    private MovieFinder movieFinder;    @Autowired(required = false)    public void setMovieFinder(MovieFinder movieFinder) &#123;        this.movieFinder = movieFinder;    &#125;    // ...&#125;\n\n从 Spring Framework 5.0 开始，还可以使用 @Nullable 注解，告诉 Spring 字段可以为空。\npublic class SimpleMovieLister &#123;    @Autowired    public void setMovieFinder(@Nullable MovieFinder movieFinder) &#123;        ...    &#125;&#125;\n\n@Primary注入时如果有多个候选项，优先注入使用该注解的 bean。\n@Qualifier有的时候同一种类型的 bean 可能有多个，@Autowired 只能基于类型注入，如果希望注入某个指定的 bean，可以使用该注解表名具体要注入的 bean 的 id。@Qualifier 注解可以用于字段、setter 或者构造方法的参数。\npublic class MovieRecommender &#123;    @Qualifier(&quot;id&quot;)    private MovieCatalog movieCatalog;    private CustomerPreferenceDao customerPreferenceDao;    @Autowired    public void prepare(@Qualifier(&quot;id&quot;)MovieCatalog movieCatalog,            CustomerPreferenceDao customerPreferenceDao) &#123;        this.movieCatalog = movieCatalog;        this.customerPreferenceDao = customerPreferenceDao;    &#125;    // ...&#125;\n\n还可以用于给 bean 添加标识，在注入的时候使用此标识。\n@Component(&quot;student&quot;)@Qualifier(&quot;12&quot;)public class StudentBean &#123;&#125;\n\n@Resource该注解是 JSR250 提供的注解，如有指定的 name 属性，先按该属性进行 byName 方式查找装配；其次再进行默认的 byName 方式进行装配；如果以上都不成功，则按 byType 的方式自动装配。\npublic class User &#123;    //如果允许对象为null，设置required = false,默认为true    @Resource(name = &quot;cat2&quot;)    private Cat cat;    @Resource    private Dog dog;    private String str;&#125;\n\n@PostConstruct 和@PreDestroy标识 bean 的初始化方法和销毁方法，在 xml 配置中提到过。\npublic class CachingMovieLister &#123;    @PostConstruct    public void populateMovieCache() &#123;        // populates the movie cache upon initialization...    &#125;    @PreDestroy    public void clearMovieCache() &#123;        // clears the movie cache upon destruction...    &#125;&#125;\n\n@Value该注解可以直接在属性上使用，Spring 会将值注入到属性中去，不可以用于静态属性，无法注入集合。\n@Componentclass Person &#123;    @Value(&quot;chang&quot;)    private String name;      @Value(&quot;12&quot;)    private int age;&#125;\n\n有时候可以将一些属性放入配置文件中，@Value 可以取出配置文件中的这些属性，使用方式如下：\n\n编写配置文\n\nname=changage=12\n\n\n在 Spring 的 xml 配置文件中指出配置文件的位置\n&lt;context:property-placeholder location=&quot;properties配置文件位置&quot; /&gt;\n\n使用 @Value 注解\n  @Component  class Person &#123;      @Value(&quot;$&#123;name&#125;&quot;)      private String name;      @Value(&quot;$&#123;age&#125;&quot;)      private int age;  &#125;## @PropertySource`@Value` 注解要使用配置文件中的值，需要在 xml 中配置 `properties` 文件的位置。不过如果使用纯 Java 的方式配置以后，要怎么使用呢？其实 Spring 提供了另一个注解来代替这个配置，就是 `@PropertySource`。```java@Component@PropertySource(&quot;配置文件位置&quot;)class Person &#123;    @Value(&quot;$&#123;name&#125;&quot;)    private String name;      @Value(&quot;$&#123;age&#125;&quot;)    private int age;&#125;\n\n@Bean除了可以通过 Spring 自动扫描向容器中添加 bean，还可以手动的向容器中加入，@Bean 注解就用来实现这样的功能，类似于 xml 配置文件中的工厂方法。这种方式一般用于第三方框架，或者对象创建比较复杂的情况。\n@Configurationpublic class RedisConfig &#123;    @Bean    public User user() &#123;        return new User();    &#125;&#125;\n\n默认情况下会使用方法名会作为 bean 的默认 id，如果需要定义成其他的 id 可以使用 @Bean(&quot;id&quot;)。前面提到的 @Scope 和 @Qualifier 注解也可以用于 @Bean 注解的方法，还可以给 bean 添加别名和描述。\n@Configurationpublic class AppConfig &#123;    @Bean(&#123;&quot;dataSource&quot;, &quot;subsystemA-dataSource&quot;, &quot;subsystemB-dataSource&quot;&#125;)    public DataSource dataSource() &#123;        // instantiate, configure and return DataSource bean...    &#125;&#125;\n\n@Configurationpublic class AppConfig &#123;    @Bean    @Description(&quot;Provides a basic example of a bean&quot;)    public Thing thing() &#123;        return new Thing();    &#125;&#125;\n\n@Bean 注解标注的方法支持自动注入，下面的列子中 Spring 会从容器中找到 Person 类型的 bean 赋给 person 参数。\n@Configurationpublic class RedisConfig &#123;     @Bean    public User user(Person person) &#123;        return new User(person);    &#125;&#125;\n\n如果是在 @Configuration 注解的配置类中，可以直接调用 @Bean 注解过的方法进行注入，其他情况下该方法不可使用。\n@Configurationpublic class RedisConfig &#123;       @Bean    public Person person() &#123;        return new Person();    &#125;      @Bean    public User user() &#123;        // 这里直接调用了person方法注入对象。        return new User(person());    &#125;&#125;\n\n@Import 注解@Import 注解的作用是向容器中添加一个配置类或者 bean。\n@Configurationpublic class ConfigA &#123;    @Bean    public A a() &#123;        return new A();    &#125;&#125;@Configuration@Import(ConfigA.class)public class ConfigB &#123;    @Bean    public B b() &#123;        return new B();    &#125;&#125;\n\nBean 优先级对于不同配置中具有相同 id 的 bean，它们之间的优先级关系为：xml 配置 &gt;@Bean 配置 &gt; @Component 配置。\n","categories":["Spring学习笔记"],"tags":["Spring"]},{"title":"计算机的启动.md","url":"/2023/02/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E5%90%AF%E5%8A%A8/","content":"第一条指令程序在运行时必须被加载到内存中，之后 CPU 才能从内存中读取程序相关的指令并执行，操作系统本身是一种程序，自然也要遵循这样的过程。不过这里有一个问题，执行其他程序的时候，都是由操作系统将程序读取到内存中的，那么操作系统又是被谁加载进内存中的呢？答案是 BIOS 程序。\n下图是计算机在启动时加载操作系统的简要流程，当我们按下电源的时候，会首先执行 BIOS 程序，之后它会从硬盘中读取引导程序，引导程序再将操作系统加载进内存中。\n\n所以在计算机通电后，执行的第一条指令是属于 BIOS 程序的，那么接下来的问题是，BOIS 程序在什么地方？它又是怎么被加载进内存的？CPU 是如何开始执行它的第一条指令的？\nBIOS 程序作为计算机启动后执行的第一个程序，肯定不能像操作系统一样存放在硬盘上，当然它也不能直接存放在内存中，因为内存断电以后所有的数据就都消失了。事实上 BIOS 被存放在主板上的一个只读存储器（ROM）里，ROM 的特点在于断电后数据不会丢失，当计算机加电之后，硬件逻辑会将 ROM 中存放的 BIOS 程序读取到内存中 0xFFFF0 这个位置，并强制将 CS 寄存器的值为 0xF000、IP 寄存器的值为 0xFFF0，这样 CS: IP 就指向了 0xFFFF0 这个地址位置，CPU 开始执行第一条指令时就从 0xFFFF0 这个内存地址读取，BIOS 程序开始被执行。\nBIOS 程序BIOS（Basic Input&#x2F;Output System）是基本输入输出系统的简称，为计算机提供最低级、最直接的硬件控制与支持，最主要功能包括：\n\n上电后的系统自检和初始化\n中断服务\n基础 IO 服务\n加载操作系统\n\n前文中已经了解到 BIOS 程序会被加载到 0xFFFF0 这个位置，CPU 也会从这个位置的指令开始执行 BIOS 程序，那么 BIOS 程序在执行过程中主要干了以下这么几件事：\n\nBIOS 首先先进行 POST（Power－On Self Test，加电后自检），主要检测系统中一些关键设备是否存在和能否正常工作，例如内存和显卡等设备。如果硬件出现问题，主板会发出不同含义的蜂鸣，并终止启动过程；如果硬件没有问题，继续执行后续流程。\n构建中断向量表和 BIOS 数据区，加载中断服务程序。\nBIOS 开始搜寻可引导的存储设备，如果找到，则将存储设备中的引导扇区读入物理内存 0x7C00 处，并跳转到 0x7C00 继续执行，从而将 CPU 交给引导扇区中的程序。\n\n引导程序BIOS 将磁盘中的引导程序加载到内存中并将 CPU 控制权交给引导程序后，计算机开始与磁盘中的操作系统有了联系。\n此时 BOIS 加载到内存中的内容称为主引导记录（MBR），位于磁盘 0 盘面 0 磁道 1 扇区，也就是磁盘最开始的 512 个字节。当然不是所有的磁盘都装有操作系统，所以将这 512 个字节的最后两个字节规定为了标志位，如果它们的值是 0x55 和 0xAA。\n\n计算机硬件体系结构的设计与 BIOS 的联手操作：理论上，计算机可以安装任何操作系统，每个操作系统设计者都可以设计出一套自己操作系统的启动方案，而操作系统和 BIOS 通常是由不同的团队设计和开发，为了协同工作，必须建立协调机制。“两头约定”、“定位识别”。对操作系统，约定操作系统设计者必须把最开始执行的程序，即引导程序定位在启动扇区（0 盘面 0 磁道 1 扇区）。对 BIOS，约定接收到启动操作系统命令后，定位识别只从启动扇区把代码加载到 0x07C00 内存这个位置。\n\n主引导记录中的内容如下：\n\n启动代码（第 1-446 字节）：检查分区表正确性，加载并跳转到分区；\n分区表（第 447-510 字节）：描述分区状态和位置；\n主引导记录签名（第 511-512 字节）：当取值为 0x55 和 0xAA 表示当前主引导记录有效。\n\n\n其中第一部分的 446 个字节中存储的就是启动代码，BIOS 结束后执行的就是这段程序。因为在实际使用中，我们可能会将一个磁盘划分为不同的分区，而操作系统会被安装在其中一个分区，那么接下来该将计算机的控制权交给哪个分区就是有这段启动代码来控制的。\n在每个分区的第 1 个扇区是本分区的分区引导扇区，主要格式如下：\n\nJMP 指令：跳转到启动代码；\n文件卷头：文件系统相关描述；\n启动代码：跳转到加载程序；\n结束标志：标志此扇区为分区引导扇区。\n\n\n主引导记录将控制权交给分区后，分区中的启动代码便开始执行，跳转到系统加载程序，加载程序会加载操作系统内核并将控制权交给内核，到此操作系统就正式开始执行了。\n参考资料\n操作系统 - 清华大学 - 学堂在线 (xuetangx.com)\nLinux操作系统启动流程 - 浪漫De刺猬 - 博客园 (cnblogs.com)\n史上最详细linux启动过程讲解—没有之一 - 腾讯云开发者社区-腾讯云 (tencent.com)\n计算机是如何启动的？- 阮一峰的网络日志 (ruanyifeng.com)\n浅谈操作系统-启动过程 - 知乎 (zhihu.com)\nBIOS到底是什么 - 知乎 (zhihu.com)\n从开机加电到执行main函数之前的过程 | 蘑菇先生学习记 (xtf615.com)\n2. 启动BIOS，准备实模式下的中断向量表和中断服务程序 - 简书 (jianshu.com)\n\n","categories":["操作系统"]},{"title":"Spring中的AOP配置.md","url":"/2023/03/14/Spring%E4%B8%AD%E7%9A%84AOP%E9%85%8D%E7%BD%AE/","content":"基于注解的配置启用@AspectJ 支持Spring 中使用 @AspectJ 切面，所以首先需要启用，下面展示了 java 和 xml 两种配置方式。\n@Configuration@EnableAspectJAutoProxypublic class AppConfig &#123;&#125;\n\n&lt;aop:aspectj-autoproxy/&gt;\n\n声明切面启用 @AspectJ 支持后，Spring 会自动检测应用程序上下文中使用 @AspectJ 注解的 Bean 作为切面用于配置 Spring AOP，该 bean 和普通的类一样，可以有自己的方法和属性。\n&lt;bean id=&quot;myAspect&quot; class=&quot;org.xyz.NotVeryUsefulAspect&quot;&gt;    &lt;!-- configure properties of the aspect here --&gt;&lt;/bean&gt;\n\npackage org.xyz;import org.aspectj.lang.annotation.Aspect;@Aspectpublic class NotVeryUsefulAspect &#123;&#125;\n\n声明切入点在切面的方法上添加 @Pointcut 注解用于表示一个切面，下面的示例定义一个名为 anyOldTransfer 的切入点，该切入点与任何名为 transfer 的方法的执行相匹配。\n@Pointcut(&quot;execution(* transfer(..))&quot;)// the pointcut expressionprivate void anyOldTransfer() &#123;&#125;// the pointcut signature\n\nSpring AOP 支持以下在切入点表达式中使用的 AspectJ 切入点指示符如下：\n\nexecution：用于匹配方法执行的连接点。这是使用 Spring AOP 时要使用的主要切入点指示符。\nwithin：将匹配限制为某些类型内的连接点 (使用 Spring AOP 时，在匹配类型内声明的方法的执行)。\nthis：将匹配限制为连接点 (使用 Spring AOP 时方法的执行)，其中 bean 引用 (Spring AOP 代理) 是给定类型的实例。\ntarget：将目标对象 (正在代理的应用程序对象) 是给定类型的实例的连接点 (使用 Spring AOP 时，方法的执行) 限制为匹配。\nargs：将参数限制为给定类型的实例的连接点 (使用 Spring AOP 时方法的执行) 限制匹配。\n@target：将执行对象的类具有给定类型的注解的连接点 (使用 Spring AOP 时，方法的执行) 限制为匹配。\n@args：限制匹配的连接点 (使用 Spring AOP 时方法的执行)，其中传递的实际参数的运行时类型具有给定类型的 注解。\n@within：将匹配限制为具有给定注解的类型内的连接点 (使用 Spring AOP 时，使用给定注解的类型中声明的方法的执行)。\n@annotation：将匹配限制为连接点的主题 (在 Spring AOP 中正在执行的方法) 具有给定注解的连接点。\n\n切入点示例\n任何公共方法的执行：\n\nexecution(public * *(..))\n\n\n名称以 set 开头的任何方法的执行：\n\nexecution(* set*(..))\n\n\nAccountService 接口定义的任何方法的执行：\n\nexecution(* com.xyz.service.AccountService.*(..))\n\n\nservice 软件包中定义的任何方法的执行：\n\nexecution(* com.xyz.service.*.*(..))\n\n\n服务包或其子包之一中定义的任何方法的执行：\n\nexecution(* com.xyz.service..*.*(..))\n\n\n服务包中的任何连接点 (仅在 Spring AOP 中执行方法)：\n\nwithin(com.xyz.service.*)\n\n\n服务包或其子包之一中的任何连接点 (仅在 Spring AOP 中执行方法)：\n\nwithin(com.xyz.service..*)\n\n\n代理实现 AccountService 接口的任何连接点 (仅在 Spring AOP 中执行方法)：\n\nthis(com.xyz.service.AccountService)\n\n\n目标对象实现 AccountService 接口的任何连接点 (仅在 Spring AOP 中执行方法)：\n\ntarget(com.xyz.service.AccountService)\n\n\n任何采用单个参数且运行时传递的参数为 Serializable 的连接点 (仅在 Spring AOP 中是方法执行)：\n\nargs(java.io.Serializable)\n\n\n目标对象带有 @Transactional 注解的任何连接点 (仅在 Spring AOP 中执行方法)：\n\n@target(org.springframework.transaction.annotation.Transactional)\n\n\n目标对象的声明类型具有 @Transactional 注解 的任何连接点 (仅在 Spring AOP 中是方法执行)：\n\n@within(org.springframework.transaction.annotation.Transactional)\n\n\n执行方法带有 @Transactional 注解的任何连接点 (仅在 Spring AOP 中是方法执行)：\n\n@annotation(org.springframework.transaction.annotation.Transactional)\n\n\n任何采用单个参数且传递的参数的运行时类型具有 @Classified 注解 的连接点 (仅在 Spring AOP 中是方法执行)。\n\n@args(com.xyz.security.Classified)\n\n\n名为 tradeService 的 Spring bean 上的任何连接点 (仅在 Spring AOP 中执行方法)：\n\nbean(tradeService)\n\n\nSpring Bean 上具有与通配符表达式 *Service 匹配的名称的任何连接点 (仅在 Spring AOP 中是方法执行)：\n\nbean(*Service)\n\n组合切入点@Pointcut(&quot;execution(public * *(..))&quot;)private void anyPublicOperation() &#123;&#125; (1)@Pointcut(&quot;within(com.xyz.someapp.trading..*)&quot;)private void inTrading() &#123;&#125; (2)@Pointcut(&quot;anyPublicOperation() &amp;&amp; inTrading()&quot;)private void tradingOperation() &#123;&#125; (3)\n\n\n(1) anyPublicOperation 匹配方法执行联接点是否表示任何公共方法的执行。\n(2) inTrading 如果 Transaction 模块中有方法执行则匹配。\n(3) tradingOperation 匹配，如果方法执行代表 Transaction 模块中的任何公共方法。\n\n通知前置通知前置通知在目标方法执行前执行。\nimport org.aspectj.lang.annotation.Aspect;import org.aspectj.lang.annotation.Before;@Aspectpublic class BeforeExample &#123;    @Before(&quot;com.xyz.myapp.SystemArchitecture.dataAccessOperation()&quot;)    public void doAccessCheck() &#123;        // ...    &#125;&#125;\n\n返回通知后置通知在方法执行后通知。\nimport org.aspectj.lang.annotation.Aspect;import org.aspectj.lang.annotation.AfterReturning;@Aspectpublic class AfterReturningExample &#123;    @AfterReturning(&quot;com.xyz.myapp.SystemArchitecture.dataAccessOperation()&quot;)    public void doAccessCheck() &#123;        // ...    &#125;&#125;\n\n可以捕获目标方法的返回值。\nimport org.aspectj.lang.annotation.Aspect;import org.aspectj.lang.annotation.AfterReturning;@Aspectpublic class AfterReturningExample &#123;    @AfterReturning(        pointcut=&quot;com.xyz.myapp.SystemArchitecture.dataAccessOperation()&quot;,        returning=&quot;retVal&quot;)    public void doAccessCheck(Object retVal) &#123;        // ...    &#125;&#125;\n\n异常通知在目标方法抛出错误时执行，可以对抛出的异常进行指定。\nimport org.aspectj.lang.annotation.Aspect;import org.aspectj.lang.annotation.AfterThrowing;@Aspectpublic class AfterThrowingExample &#123;    @AfterThrowing(        pointcut=&quot;com.xyz.myapp.SystemArchitecture.dataAccessOperation()&quot;,        throwing=&quot;ex&quot;)    public void doRecoveryActions(DataAccessException ex) &#123;        // ...    &#125;&#125;\n\n最终通知目标方法后执行后，并且无论目标方法是否出现异常都会执行。\nimport org.aspectj.lang.annotation.Aspect;import org.aspectj.lang.annotation.AfterReturning;@Aspectpublic class AfterReturningExample &#123;    @AfterReturning(&quot;com.xyz.myapp.SystemArchitecture.dataAccessOperation()&quot;)    public void doAccessCheck() &#123;        // ...    &#125;&#125;\n\n环绕通知方法的第一个参数必须为 ProceedingJoinPoint 类型，在 ProceedingJoinPoint 上调用 proceed() 会使底层方法执行。proceed 方法也可以传入 Object[]，数组中的值用作方法执行时的参数。\nimport org.aspectj.lang.annotation.Aspect;import org.aspectj.lang.annotation.Around;import org.aspectj.lang.ProceedingJoinPoint;@Aspectpublic class AroundExample &#123;    @Around(&quot;com.xyz.myapp.SystemArchitecture.businessService()&quot;)    public Object doBasicProfiling(ProceedingJoinPoint pjp) throws Throwable &#123;        // start stopwatch        Object retVal = pjp.proceed();        // stop stopwatch        return retVal;    &#125;&#125;\n\n访问 JoinPoint任何通知方法都可以将类型 org.aspectj.lang.JoinPoint 的参数声明为第一个参数，在环绕通知中必须声明类型 JoinPoint 的子类 ProceedingJoinPoint 的第一个参数。JoinPoint 接口提供了许多有用的方法：\n\ngetArgs()：返回方法参数。\ngetThis()：返回代理对象。\ngetTarget()：返回目标对象。\ngetSignature()：返回建议使用的方法的描述。\ntoString()：打印有关所建议方法的有用描述。\n\n传递参数切入点表达式的 args(account,..) 部分有两个作用。首先，它将匹配限制为仅方法采用至少一个参数并且传递给该参数的参数是 Account 的实例的方法执行。其次，它通过 account 参数使实际的 Account 对象可用于通知。\n@Before(&quot;com.xyz.myapp.SystemArchitecture.dataAccessOperation() &amp;&amp; args(account,..)&quot;)public void validateAccount(Account account) &#123;    // ...&#125;\n\n@Pointcut(&quot;com.xyz.myapp.SystemArchitecture.dataAccessOperation() &amp;&amp; args(account,..)&quot;)private void accountDataAccessOperation(Account account) &#123;&#125;@Before(&quot;accountDataAccessOperation(account)&quot;)public void validateAccount(Account account) &#123;    // ...&#125;\n\n还可以使用 argNames 属性指明要传递的参数，如果第一个参数是 JoinPoint，ProceedingJoinPoint 或 JoinPoint.StaticPart 类型，则可以不用指出。\n@Before(value=&quot;com.xyz.lib.Pointcuts.anyPublicMethod() &amp;&amp; target(bean) &amp;&amp; @annotation(auditable)&quot;,        argNames=&quot;bean,auditable&quot;)public void audit(Object bean, Auditable auditable) &#123;    AuditCode code = auditable.value();    // ... use code and bean&#125;\n\n基于 XML 的配置&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;    &lt;context:component-scan base-package=&quot;tech.pdai.springframework&quot; /&gt;    &lt;aop:aspectj-autoproxy/&gt;    &lt;!-- 目标类 --&gt;    &lt;bean id=&quot;demoService&quot; class=&quot;tech.pdai.springframework.service.AopDemoServiceImpl&quot;&gt;        &lt;!-- configure properties of bean here as normal --&gt;    &lt;/bean&gt;    &lt;!-- 切面 --&gt;    &lt;bean id=&quot;logAspect&quot; class=&quot;tech.pdai.springframework.aspect.LogAspect&quot;&gt;        &lt;!-- configure properties of aspect here as normal --&gt;    &lt;/bean&gt;    &lt;aop:config&gt;        &lt;!-- 配置切面 --&gt;        &lt;aop:aspect ref=&quot;logAspect&quot;&gt;            &lt;!-- 配置切入点 --&gt;            &lt;aop:pointcut id=&quot;pointCutMethod&quot; expression=&quot;execution(* tech.pdai.springframework.service.*.*(..))&quot;/&gt;            &lt;!-- 环绕通知 --&gt;            &lt;aop:around method=&quot;doAround&quot; pointcut-ref=&quot;pointCutMethod&quot;/&gt;            &lt;!-- 前置通知 --&gt;            &lt;aop:before method=&quot;doBefore&quot; pointcut-ref=&quot;pointCutMethod&quot;/&gt;            &lt;!-- 后置通知；returning属性：用于设置后置通知的第二个参数的名称，类型是Object --&gt;            &lt;aop:after-returning method=&quot;doAfterReturning&quot; pointcut-ref=&quot;pointCutMethod&quot; returning=&quot;result&quot;/&gt;            &lt;!-- 异常通知：如果没有异常，将不会执行增强；throwing属性：用于设置通知第二个参数的的名称、类型--&gt;            &lt;aop:after-throwing method=&quot;doAfterThrowing&quot; pointcut-ref=&quot;pointCutMethod&quot; throwing=&quot;e&quot;/&gt;            &lt;!-- 最终通知 --&gt;            &lt;aop:after method=&quot;doAfter&quot; pointcut-ref=&quot;pointCutMethod&quot;/&gt;        &lt;/aop:aspect&gt;    &lt;/aop:config&gt;    &lt;!-- more bean definitions for data access objects go here --&gt;&lt;/beans&gt;","categories":["Spring学习笔记"],"tags":["Spring"]},{"title":"ucore操作系统实验：环境搭建.md","url":"/2023/04/20/ucore%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C%EF%BC%9A%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/","content":"源码和文档实验的源码可以从 官方仓库 获取，需要注意的是目前实验所用的代码已经改为 Rust 语言，如果想要 C 语言的版本，需要切换到 x86-32 分支。\n\n下载之后可以看到目录结构如下，其中 labcodes 为实验所用的源码，labcodes_answer 为实验的参考答案，遇到不会做的题目可以进行参考。\n\n 实验的官方手册为：ucore实验操作手册 包含了实验内容以及实验相关的一些拓展知识。\nGCC 安装根据官方文档，安装 gcc 之后还需要再安装相 gcc 编译时所需的依赖，不过这些在 ubuntu 里安装起来很容易，两条命令就可搞定。\nsudo apt-get install gccsudo apt-get install build-essential\n\n\n\nQEMU 安裝文档中安装 QEMU 使用的命令如下：\nsudo apt-get install qemu-system\n\n\n它会安装很多程序，总共有 600M，而我们在实验中只用到 qemu-system-i386，所以可以只安装该程序：\nsudo apt-get install qemu-system-i386\n\n切换到 labcodes_answer/lab1_result 目录，执行 make qemu 命令，如果弹出 QEMU 程序，并开始正常执行，则环境到此配置成功。\n\n\n出现的问题lab1 编译时出现 &#39;obj/bootbloc.out&#39; size: 600 bytes\n在 lab1_result 中使用进行编译代码的时候有可能会出现如下结果，解决方案是可以使用低版本的 gcc，比如 gcc-4.8。\n因为 lab2_result 是可以编译成功的，所有对比与 bootblock 相关的文件，发现在 bootmian.c 中有两行不同，进行修改后发现可以编译成功。\n\n","categories":["ucore操作系统实验"],"tags":["操作系统"]},{"title":"npm源管理.md","url":"/2022/06/19/npm%E6%BA%90%E7%AE%A1%E7%90%86/","content":"默认管理方式安装完 node 之后，默认的原始源是：\nhttps://registry.npmjs.org/\n\n在使用 npm 命令安装包的时候，可以使用 --registry 选项指定源：\n//本次从淘宝仓库源下载npm --registry=https://registry.npm.taobao.org install\n\n每次使用命令行时都手动指定源比较麻烦，所以 npm 提供了配置命令用来设置源，配置的源有多个，但只有一个是生效的：\n//设置淘宝源npm config set registry https://registry.npm.taobao.org//设置公司的源npm config set registry http://127.0.0.1:4873//查看源，可以看到设置过的所有的源npm config get registry\n\n也可以修改 ~/.npmrc，添加源的设置：\nregistry = https://registry.npm.taobao.org\n\n使用 nrm 管理源 nrm ​ 是一个 NPM 源管理器，可以使用 ​ nrm 在不同的源切换。\n// 安装nrmnpm install -g nrm// 列出当前所有源nrm ls\n\nnrm ls 命令的输出结果如下，其中带 * 的是当前使用的源。\n* npm -------- https://registry.npmjs.org/  yarn ------- https://registry.yarnpkg.com/  cnpm ------- http://r.cnpmjs.org/  taobao ----- https://registry.npm.taobao.org/  nj --------- https://registry.nodejitsu.com/  npmMirror -- https://skimdb.npmjs.com/registry/  edunpm ----- http://registry.enpmjs.org/\n\n如果想要切花源，比如切换到 taobao，可以使用如下命令：\nnrm use taobao\n\n可以增加定制的源，命令如下：\nnrm add  &lt;registry&gt; &lt;url&gt; [home]\n\n可以删除指定的源，命令如下：\nnrm del &lt;registry&gt;\n\n还可以通过 nrm test ​ 测试相应源的响应时间。\nnrm test npm ","tags":["javascript","npm"]},{"title":"Java 中的 char 类型能否存储中文.md","url":"/2022/02/11/Java%20%E4%B8%AD%E7%9A%84%20char%20%E7%B1%BB%E5%9E%8B%E8%83%BD%E5%90%A6%E5%AD%98%E5%82%A8%E4%B8%AD%E6%96%87/","content":"概念解析先来看几个比较容易混淆的概念：\n\n字符： 简单的说字符就是各种文字和符号的总称，一个字符可以是一个中文汉字、一个英文字母、一个阿拉伯数字、一个标点符号、一个图形符号（如 emjoy）或者控制符号（如回车）等。\n字符集： 顾名思义，字符集就是多个字符的集合，不同的字符集中包含的字符不一样、对字符的编码方式也不一样。例如 GB 2312 是中国国家标准的简体中文字符集，主要收录了简化汉字（6763 个）在内的 7445 个图形字符，而 ASCII 字符集只包含了 128 字符，另外常见的字符集还有：GBK 字符集、GB 18030 字符集、Big 5 字符集、Unicode 字符集等。\n码点值：在每个字符集中都会字符进行编号，字符对应的编号就是该字符在该字符集中的码点值，比如在 ASCII 字符集中，字母 A 对应的编号 65，那么 65 就是字符 A 在 ASCII 字符集中的码点值。\n字符编码： 字符编码就是指的是一种映射规则，根据这个映射规则可以将某个字符映射成对应的二进制数据，简单的讲就是字符对应的码点值如何在计算机中存储。例如 ASCII 字符编码规定每个字符使用一个字节来存储，并且字节中的低 7 位表示字符对应的码点值，在这个编码规则下字母 A 的码点值是 65（ASCII 码），用单字节表示就是 0 x 41，因此写入存储设备的时候就是二进制的 01000001。\n\n编码模型目前存在两种编码模型，简单编码模型和现代编码模型。\n简单编码模型在这种编码模型里，一个字符集定义了这个字符集里包含什么字符，同时把每个字符如何对应成计算机里的比特也进行了定义，最典型的是 ASCII 字符集，直接定义了 A -&gt; 0100 0001。\n现代编码模型在现代编码模型里要知道一个字符如何映射成计算机里比特，需要经过如下几个步骤：\n\n知道一个系统需要支持哪些字符，这些字符的集合被称为字符表（Character repertoire）；\n给字符表里的抽象字符编上一个数字，也就是字符集合到一个整数集合的映射，这种映射称为编码字符集（CCS: Coded Character Set），unicode 字符集就是属于这一层的概念，它跟计算机里的什么进制啊没有任何关系，它是完全数学的抽象的。\n将 CCS 里字符对应的整数转换成有限长度的比特值，便于以后计算机使用一定长度的二进制形式表示该整数，这个对应关系被称为字符编码表（CEF: Character Encoding Form）UTF-8，UTF-16 都属于这层。\n对于 CEF 得到的比特值具体如何在计算机中进行存储传输，由于存在大端小端的问题，这跟跟具体的操作系统相关，字符编码方案（CES: Character Encoding Scheme）考虑的就是这个问题。\n\nASCII 和 UnicodeASCII 字符集前文中提到过 ASCII 字符集使用了简单编码模型，也就是说在定义字符集的同时一并定义了字符在计算机中如何使使用二进制表示，一次性将现代编码模型中的前三步完成了。下图展示了 ASCII 字符集中字符与码点值之间的关系，同时 ASCII 字符集还规定了在计算机中每个字符占用一个字节，最前面的 1 位统一规定为 0，后七位位字符码点值对应的二进制。\n\nUnicode 字符集ASCII 字符集表示的字符量有限，即使后续对其有过拓展，但受限于单个字节的存储方式，最多也只能表示 256 个字符。Unicode 字符集是一个很大的字符集合，现在的规模可以容纳 100 多万个符号。每个符号的编码都不一样，比如，U+0639 表示阿拉伯字母 Ain，U+0041 表示英语的大写字母 A，U+4 E 25 表示汉字 “严”。\nUnicode 使用的是现代编码模型，定义出字符集以后只完成了前两步，还需要考虑在计算机中如何表示，于是就出现了 UTF-8、UTF-6 以及 UTF-32 这些编码方式，它们的作用简单的理解就是将字符对应的码点值映射成唯一的二进制数据。\nUTF-8 编码UTF-8 最大的一个特点，就是它是一种变长的编码方式，它可以使用 1~4 个字节表示一个符号，根据不同的符号而变化字节长度，下图总结了 UTF-8 的编码规则。\n\nUTF-8 在存储英文字母时，使用一个字节来存储，存储中文时，使用的是三个字节。以汉字 “严” 为例，“严” 的 unicode 是 U+4 E 25（100111000100101），根据上表，可以发现 4 E 25 处在第三行的范围内（0000 0800-0000 FFFF），因此 “严” 的 UTF-8 编码需要三个字节，即格式是 “1110 xxxx 10 xxxxxx 10 xxxxxx”。然后，从“严” 的最后一个二进制位开始，依次从后向前填入格式中的 x，多出的位补 0。这样就得到了，“严”的 UTF-8 编码是“11100100 10111000 10100101”。\nUTF-16UTF-16 也是一种可变长的编码方式，不过它编码的最小单元是 2 字节，也就是说即使存储的英文字母，也需要两个字节的空间，下图展示了 UTF-16 的编码规则。\n\n由于 UTF-16 使用了两个字节作为最小单元，所以需要考虑存储时大小端的问题，于是 UTF-16 中就包括三种：UTF-16，UTF-16 BE（Big Endian）和 UTF-16 LE（Little Endian）。UTF-16 BE 和 UTF-16 LE 不难理解，分别代表大端和小端方式，而 UTF-16 就需要通过在文件开头以名为 BOM（Byte Order Mark）的字符来表明文件是 Big Endian 还是 Little Endian，开头是 FEFF 则是大端，FFEF 则是小端。\nJava 中的 char 类型能否存储中文答案是肯定的，Java 中的 char 可以用来存储中文。\nJava 中的 char 固定占两个字节，使用 UTF-16 的编码方式对 Unicode 字符集中的 U+0000 到 U+FFFF 进行编码，所以处在这个范围内的字符都是可以被存储的，但是如果超出了这个范围，就无法再使用 char 来存储了，必须使用 String 来存储。\nJava 中 String 如何来存储字符串在 Java 1.8 之前，Java 使用的 char 数组来存储字符串，对于一个 char 可以表示的字符，那么就用一个 char 来存储，否则则用两个 char 来存储，这也是字符串可以用来存储 U+0000 到 U+FFFF 之外字符的原因。不过在使用 Java 中 String 的时候需要注意，如果字符串中存在一些不常用的字符，在获取字符串长度的时候可能会出现问题，应为最终的长度统计的是 char 的个数，而不是字符串中字符的个数。\npublic static void main(String[] args) &#123;    System.out.println(&quot;🀎&quot;.length());&#125;// 输出结果为 2\n\nJava 中 String 底层数据结构由 char[] 换成 byte[]更换的主要目的是为了节省存储空间，原先使用 char 数组来存储的时候，即使是存储的英文字母，也必须使用两个字节，这显然是非常浪费存储空间的，所以在 Java 1.9 之后使用 byte 数组做了替换。当存储的内容只有英文字母（单字节字符）的时候，那么就用一个字节来存储一个字符，当字符串中由其他字符的时候，就换成双字节来存储。\n参考资料\n字符、字符集、字符编码的基础知识科普 - 知乎 (zhihu.com)\n代码点(Code Point)和代码单元(Code Unit)_GeekLeee的博客-CSDN博客\n刨根究底字符编码之十——Unicode字符集的编码方式以及码点、码元 - 笨笨阿林 - 博客园 (cnblogs.com)\nUnicode中UTF-8与UTF-16编码详解 - 掘金 (juejin.cn)\nJava中关于Char存储中文到底是2个字节还是3个还是4个？- 知乎 (zhihu.com)\n\n","tags":["java"]},{"title":"SpringBoot整合Springdoc.md","url":"/2023/04/26/SpringBoot%E6%95%B4%E5%90%88Springdoc/","content":"介绍Springdoc 的作用是把应用中的接口以文档的形式展示出来，同时可以直接在文档中对接口进行测试，方便开发的进行。\n\n\n配置依赖引入根据 Springdoc官方文档，想要在项目中使用 Springdoc 只需要引入如下依赖即可：\n&lt;dependency&gt;  &lt;groupId&gt;org.springdoc&lt;/groupId&gt;  &lt;artifactId&gt;springdoc-openapi-ui&lt;/artifactId&gt;  &lt;version&gt;1.7.0&lt;/version&gt;&lt;/dependency&gt;\n\n之后即可在 http://server:port/context-path/swagger-ui.html 看到如下界面：\n\n信息配置如果想要配置额外的信息，可以在容器中注入一个 OpenAPI，这些信息将会在页面中展示。\n@Beanpublic OpenAPI springShopOpenAPI() &#123;    return new OpenAPI()            .info(new Info().title(&quot;Cfile API&quot;)                    .description(&quot;一个在线文件解析网站&quot;)                    .version(&quot;v0.0.1&quot;)                    .license(new License()                            .name(&quot;Apache 2.0&quot;)                            .url(&quot;http://www.cfile.com&quot;))                    .contact(new Contact()                            .email(&quot;changliangliang1996@foxmail.com&quot;)                            .name(&quot;chang&quot;)                            .url(&quot;http://changliangliang.github.io&quot;))            );&#125;\n\n\n扫描路径接着配置需要扫描的接口所在的包，方法是在容器中注入一个 GroupedOpenApi，如下面的配置中 Springdoc 将会扫描 com.liang.cfile.controller 但是不包括 com.liang.cfile.controller.admin 包。\n@Beanpublic GroupedOpenApi userApi() &#123;    return GroupedOpenApi.builder()            .group(&quot;user&quot;)            .packagesToScan(&quot;com.liang.cfile.controller&quot;)            .packagesToExclude(&quot;com.liang.cfile.controller.admin&quot;)            .build();&#125;\n\n需要注意的是只有类上有 @Tag 注解以及方法上有 @Operation 注解的接口才会被 Springdoc 扫描到。\n@Tag(name = &quot;用户接口&quot;)@Controller@RequestMapping(&quot;/user&quot;)public class UserController &#123;    @Operation    @GetMapping(&quot;/login&quot;)    public void login() &#123;    &#125;&#125;\n\n然后启动项目就能看到 UserController 中的借口被展示出来了。\n\nSpringdoc 还支持 api 的分组展示，只需要像容器中注入另一个 GroupedOpenApi 即可，在页面顶部选择框中能够对接口分组进行切换。\n@Beanpublic GroupedOpenApi adminApi() &#123;    return GroupedOpenApi.builder()            .group(&quot;admin&quot;)            .packagesToScan(&quot;com.liang.cfile.controller.admin&quot;)            .build();&#125;\n\n\n常用注解@Tag@Tag 注解使用在 Controller 类上，只有这样该 Controller 类才会被 Springdoc 扫描到。\n@Tag(name = &quot;用户接口&quot;, description = &quot;所有用户相关的操作&quot;)@Controller@RequestMapping(&quot;/user&quot;)public class UserController &#123;    // 省略接口&#125;\n\n\n@Operation@Operation 注解用在 Controller 类的方法上，表示当前方法是一个接口，之后会被展示在页面上。\n\n@Operation(summary = &quot;用户登陆&quot;)@GetMapping(&quot;/login&quot;)public void login() &#123;&#125;\n\n@Parameters 和 @Parameter@Parameters 注解用在方法上，@Parameter 注解用在 @Parameters 内部或者方法的参数上，可以对参数进行解释，以下两种用法都能达到效果。\n@Operation(summary = &quot;用户登陆&quot;)@GetMapping(&quot;/login&quot;)public void login(@Parameter(description = &quot;用户名&quot;) String username) &#123;&#125;\n\n@Operation(summary = &quot;用户登陆&quot;)@Parameters(&#123;        @Parameter(name = &quot;username&quot;, description = &quot;用户名&quot;)&#125;)@GetMapping(&quot;/login&quot;)public void login(String username) &#123;&#125;\n\n\n@Schema@Schema 注解用在类和属性上，不过是用在 DTO 类上，主要对 DTO 的属性进行描述，当接口方法的参数或返回值为 DTO 对象时，在页面上会展示这些描述信息。\n@Schema(name = &quot;User对象&quot;)public class User implements Serializable &#123;    private static final long serialVersionUID = 1L;    @Schema(name = &quot;id值&quot;)    @TableId(value = &quot;id&quot;, type = IdType.AUTO)    private Integer id;    @Schema(name = &quot;用户名&quot;)    private String username;    @Schema(name = &quot;密码&quot;)    private String password;    @Schema(name = &quot;邮箱&quot;)    private String email;    @Schema(name = &quot;创建时间&quot;)    private LocalDateTime created;    @Schema(name = &quot;更新时间&quot;)    private LocalDateTime updated;    @Schema(name = &quot;是否删除：0-未删除，1-删除&quot;)    private Boolean delete;    @Schema(name = &quot;用户角色：0-普通用户，1-管理员用户&quot;)    private Boolean role;&#125;\n\n@Operation(summary = &quot;用户登陆&quot;)@GetMapping(&quot;/login&quot;)public User login(@Parameter(description = &quot;用户信息&quot;) User user) &#123;    return null;&#125;\n\n\n\n参考资料\nOpenAPI 3 Library for spring-boot\nSpringBoot结合SpringDoc - lixuelong - 博客园\nSwagger3 注解使用（Open API 3）_StarJava_的博客-CSDN博客\nspringdoc-openapi 的基本使用 - 小二十七 - 博客园\n\n","categories":["SpringBoot整合组件"],"tags":["SpringBoot"]},{"title":"长连接的若干问题.md","url":"/2022/05/23/%E9%95%BF%E8%BF%9E%E6%8E%A5%E7%9A%84%E8%8B%A5%E5%B9%B2%E9%97%AE%E9%A2%98/","content":"HTTP 中的长连接在 HTTP 协议中对长短链接的定义如下：\n\n长连接：浏览器向服务器进行一次 HTTP 会话访问后，不会直接关闭底层的 TCP 连接，而是会默认保持一段时间，下一次浏览器继续访问同样的服务器时会再次利用到这个连接。\n短连接：浏览器向服务器每进行一次 HTTP 操作都要建立一个新的连接。\n\n根据两者的定义可以看出，长短连接之间最主要的区别在于是否复用底层的 TCP 连接，如果使用的是短连接，那么就每次访问的服务端的时候都需要重新建立连接，访问完毕后关闭连接；如果使用的是长链接，那么第一次访问服务端的时候会建立连接，后续对服务器的访问都使用的是该链接。\n从 HTTP&#x2F;1.1 起，默认会使用长连接，使用长连接的 HTTP 协议时会在响应头有加入这行代码：\nConnection:keep-alive\n\nKeep-Alive 不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如 Apache）中设定这个时间，实现长连接要客户端和服务端都支持长连接。\nTCP 中的长连接TCP 中实际上没有长连接的概念，因为 TCP 连接只要建立起来就会一直存在，这里所谓的长短本质上是关闭连接的时机不同，如果通信一次后立马关闭连接，那么它就是短连接（HTTP 短连接），如果建立连接后将连接保存一段时间进行复用，那么就是长连接（HTTP 长连接）。\nTCP 如何关闭连接TCP 关闭连接有如下几个时机：\n\n建立连接的双方其中一方主动关闭了连接，或者程序发生崩溃操作系统关闭了连接；\n如果连接建立之后系统突然断电了，如果这时候有数据在传输，那么数据包会因为无法确认不断的被重复发送，重复一定次数后系统会关闭连接，如果这时候没有数据在传输，那么有以下几种情况：\n如果设置了 TCP 的 KeepAlive，那么连接双反会在一定时间没有收到数据时会发送心跳，检测对方是否存活；\n如果没有设置 TCP 的 KeepAlive，那么连接将会一直存在。\n\n\n\nTCP 的 KeepAlive 机制KeepAlive 机制的主要作用是保证连接存活，具体方式是在一定时间没有收到数据的时候就发送心跳包检测连接的另一方是否存活，操作系统中有这么几个参数控制 KeepAlive：\n\nKeepalive_time：空闲时间，即多长时间连接没有发送数据时开始 KeepAlive 检测，默认情况下是两个小时；\nKeepalive_intvl：发送间隔时间\nKeepalive_probs：最多发送多少个检测数据包。\n\n不过需要注意的是 KeepAlive 并不是 TCP 的标准，所以并不是所有的操作系统都实现了该功能，所以推荐在应用层实现心跳机制。\n参考资料\nHTTP长连接实现原理 - 掘金 (juejin.cn)\nHTTP长连接和短连接原理浅析-Finclip\n4个实验，彻底搞懂TCP连接的断开_51CTO博客_tcp面向连接\n\n","tags":["计算机网络"]},{"title":"ubuntu中的网络配置.md","url":"/2022/04/19/ubuntu%E4%B8%AD%E7%9A%84%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE/","content":"配置流程从 Ubuntu 18 开始，Ubuntu 开始用 Netplan 作为网络配置的程序，于是乎想要更改网络配置，就需要编辑文件夹 /etc/netplan 里的文件，其中 01-network-manager-all.yaml 就是配置文件。\n\n编辑完配置文件后，执行如下命令使配置文件生效：\nnetplat apply\n\n之后重启网络服务\nsystemctl restart NetworkManager.service\n\n使用 ip a 命令常看网卡状态，判断是否配置成功。\n\n常用配置动态 IPnetwork:  version: 2  renderer: networkd  ethernets:    enp3s0:      dhcp4: true\n\n静态 IPnetwork:  version: 2  renderer: networkd  ethernets:    enp3s0:      addresses:        - 10.10.10.2/24      routes:         - to: default          via: 10.10.10.1      nameservers:          addresses: [10.10.10.1, 1.1.1.1]\n\n多网卡network:  version: 2  ethernets:    enred:      dhcp4: yes      dhcp4-overrides:        route-metric: 100    engreen:      dhcp4: yes      dhcp4-overrides:        route-metric: 200\n\n无密码 wifinetwork:  version: 2  wifis:    wl0:      access-points:        opennetwork: &#123;&#125;      dhcp4: yes\n\n有密码 wifinetwork:  version: 2  renderer: networkd  wifis:    wlp2s0b1:      dhcp4: no      dhcp6: no      addresses: [192.168.0.21/24]      routes:         - to: default          via: 10.10.10.1      nameservers:        addresses: [192.168.0.1, 8.8.8.8]      access-points:        &quot;network_ssid_name&quot;:          password: &quot;**********&quot;\n\n单网卡多地址（同一网段）network:  version: 2  renderer: networkd  ethernets:    enp3s0:     addresses:       - 10.100.1.38/24       - 10.100.1.39/24     gateway4: 10.100.1.1\n\n单网卡多地址（不同网段）network:  version: 2  renderer: networkd  ethernets:    enp3s0:     addresses:       - 9.0.0.9/24       - 10.0.0.10/24       - 11.0.0.11/24     #gateway4:    # unset, since we configure routes below     routes:       - to: 0.0.0.0/0         via: 9.0.0.1         metric: 100       - to: 0.0.0.0/0         via: 10.0.0.1         metric: 100       - to: 0.0.0.0/0         via: 11.0.0.1         metric: 100\n\n参考资料\nUbuntu 18.04 LTS 通过 Netplan 配置网络教程 - 腾讯云开发者社区-腾讯云\n\n","tags":["linux"]},{"title":"ucore操作系统实验：lab1.md","url":"/2023/04/19/ucore%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C%EF%BC%9Alab1/","content":"练习 1\n练习 1：理解通过 make 生成执行文件的过程。（要求在报告中写出对下述问题的回答）列出本实验各练习中对应的 OS 原理的知识点，并说明本实验中的实现部分如何对应和体现了原理中的基本概念和关键知识点。\n在此练习中，大家需要通过静态分析代码来了解：\n\n操作系统镜像文件 ucore. img 是如何一步一步生成的？(需要比较详细地解释 Makefile 中每一条相关命令和命令参数的含义，以及说明命令导致的结果)\n一个被系统认为是符合规范的硬盘主引导扇区的特征是什么？\n\n补充材料：\n如何调试 Makefile\n当执行 make 时，一般只会显示输出，不会显示 make 到底执行了哪些命令。\n如想了解 make 执行了哪些命令，可以执行：\n$ make “V&#x3D;”要获取更多有关 make 的信息，可上网查询，并请执行sdf$ man make\n\n问题 1：操作系统镜像文件 ucore. img 是如何一步一步生成的？实验源码的目录结构如下，我们切换到 ucore_lab/labcodes_answer/lab1_result 目录下执行两条命令，make clean 清除掉上一次生成的文件，make V= 编译文件生成镜像。\n\n\n执行 make V= 的全部输出如下，它会现实整个过程中执行的所有命令：\n+ cc kern/init/init.cgcc -Ikern/init/ -fno-builtin -Wall -ggdb -m32 -gstabs -nostdinc  -fno-stack-protector -Ilibs/ -Ikern/debug/ -Ikern/driver/ -Ikern/trap/ -Ikern/mm/ -c kern/init/init.c -o obj/kern/init/init.o+ cc kern/libs/readline.cgcc -Ikern/libs/ -fno-builtin -Wall -ggdb -m32 -gstabs -nostdinc  -fno-stack-protector -Ilibs/ -Ikern/debug/ -Ikern/driver/ -Ikern/trap/ -Ikern/mm/ -c kern/libs/readline.c -o obj/kern/libs/readline.o+ cc kern/libs/stdio.cgcc -Ikern/libs/ -fno-builtin -Wall -ggdb -m32 -gstabs -nostdinc  -fno-stack-protector -Ilibs/ -Ikern/debug/ -Ikern/driver/ -Ikern/trap/ -Ikern/mm/ -c kern/libs/stdio.c -o obj/kern/libs/stdio.o+ cc kern/debug/kdebug.cgcc -Ikern/debug/ -fno-builtin -Wall -ggdb -m32 -gstabs -nostdinc  -fno-stack-protector -Ilibs/ -Ikern/debug/ -Ikern/driver/ -Ikern/trap/ -Ikern/mm/ -c kern/debug/kdebug.c -o obj/kern/debug/kdebug.o+ cc kern/debug/kmonitor.cgcc -Ikern/debug/ -fno-builtin -Wall -ggdb -m32 -gstabs -nostdinc  -fno-stack-protector -Ilibs/ -Ikern/debug/ -Ikern/driver/ -Ikern/trap/ -Ikern/mm/ -c kern/debug/kmonitor.c -o obj/kern/debug/kmonitor.o+ cc kern/debug/panic.cgcc -Ikern/debug/ -fno-builtin -Wall -ggdb -m32 -gstabs -nostdinc  -fno-stack-protector -Ilibs/ -Ikern/debug/ -Ikern/driver/ -Ikern/trap/ -Ikern/mm/ -c kern/debug/panic.c -o obj/kern/debug/panic.o+ cc kern/driver/clock.cgcc -Ikern/driver/ -fno-builtin -Wall -ggdb -m32 -gstabs -nostdinc  -fno-stack-protector -Ilibs/ -Ikern/debug/ -Ikern/driver/ -Ikern/trap/ -Ikern/mm/ -c kern/driver/clock.c -o obj/kern/driver/clock.o+ cc kern/driver/console.cgcc -Ikern/driver/ -fno-builtin -Wall -ggdb -m32 -gstabs -nostdinc  -fno-stack-protector -Ilibs/ -Ikern/debug/ -Ikern/driver/ -Ikern/trap/ -Ikern/mm/ -c kern/driver/console.c -o obj/kern/driver/console.o+ cc kern/driver/intr.cgcc -Ikern/driver/ -fno-builtin -Wall -ggdb -m32 -gstabs -nostdinc  -fno-stack-protector -Ilibs/ -Ikern/debug/ -Ikern/driver/ -Ikern/trap/ -Ikern/mm/ -c kern/driver/intr.c -o obj/kern/driver/intr.o+ cc kern/driver/picirq.cgcc -Ikern/driver/ -fno-builtin -Wall -ggdb -m32 -gstabs -nostdinc  -fno-stack-protector -Ilibs/ -Ikern/debug/ -Ikern/driver/ -Ikern/trap/ -Ikern/mm/ -c kern/driver/picirq.c -o obj/kern/driver/picirq.o+ cc kern/trap/trap.cgcc -Ikern/trap/ -fno-builtin -Wall -ggdb -m32 -gstabs -nostdinc  -fno-stack-protector -Ilibs/ -Ikern/debug/ -Ikern/driver/ -Ikern/trap/ -Ikern/mm/ -c kern/trap/trap.c -o obj/kern/trap/trap.o+ cc kern/trap/trapentry.Sgcc -Ikern/trap/ -fno-builtin -Wall -ggdb -m32 -gstabs -nostdinc  -fno-stack-protector -Ilibs/ -Ikern/debug/ -Ikern/driver/ -Ikern/trap/ -Ikern/mm/ -c kern/trap/trapentry.S -o obj/kern/trap/trapentry.o+ cc kern/trap/vectors.Sgcc -Ikern/trap/ -fno-builtin -Wall -ggdb -m32 -gstabs -nostdinc  -fno-stack-protector -Ilibs/ -Ikern/debug/ -Ikern/driver/ -Ikern/trap/ -Ikern/mm/ -c kern/trap/vectors.S -o obj/kern/trap/vectors.o+ cc kern/mm/pmm.cgcc -Ikern/mm/ -fno-builtin -Wall -ggdb -m32 -gstabs -nostdinc  -fno-stack-protector -Ilibs/ -Ikern/debug/ -Ikern/driver/ -Ikern/trap/ -Ikern/mm/ -c kern/mm/pmm.c -o obj/kern/mm/pmm.o+ cc libs/printfmt.cgcc -Ilibs/ -fno-builtin -Wall -ggdb -m32 -gstabs -nostdinc  -fno-stack-protector -Ilibs/  -c libs/printfmt.c -o obj/libs/printfmt.o+ cc libs/string.cgcc -Ilibs/ -fno-builtin -Wall -ggdb -m32 -gstabs -nostdinc  -fno-stack-protector -Ilibs/  -c libs/string.c -o obj/libs/string.o+ ld bin/kernelld -m    elf_i386 -nostdlib -T tools/kernel.ld -o bin/kernel  obj/kern/init/init.o obj/kern/libs/readline.o obj/kern/libs/stdio.o obj/kern/debug/kdebug.o obj/kern/debug/kmonitor.o obj/kern/debug/panic.o obj/kern/driver/clock.o obj/kern/driver/console.o obj/kern/driver/intr.o obj/kern/driver/picirq.o obj/kern/trap/trap.o obj/kern/trap/trapentry.o obj/kern/trap/vectors.o obj/kern/mm/pmm.o  obj/libs/printfmt.o obj/libs/string.o+ cc boot/bootasm.Sgcc -Iboot/ -fno-builtin -Wall -ggdb -m32 -gstabs -nostdinc  -fno-stack-protector -Ilibs/ -Os -nostdinc -c boot/bootasm.S -o obj/boot/bootasm.o+ cc boot/bootmain.cgcc -Iboot/ -fno-builtin -Wall -ggdb -m32 -gstabs -nostdinc  -fno-stack-protector -Ilibs/ -Os -nostdinc -c boot/bootmain.c -o obj/boot/bootmain.o+ cc tools/sign.cgcc -Itools/ -g -Wall -O2 -c tools/sign.c -o obj/sign/tools/sign.ogcc -g -Wall -O2 obj/sign/tools/sign.o -o bin/sign+ ld bin/bootblockld -m    elf_i386 -nostdlib -N -e start -Ttext 0x7C00 obj/boot/bootasm.o obj/boot/bootmain.o -o obj/bootblock.o&#x27;obj/bootblock.out&#x27; size: 488 bytesbuild 512 bytes boot sector: &#x27;bin/bootblock&#x27; success!dd if=/dev/zero of=bin/ucore.img count=1000010000+0 records in10000+0 records out5120000 bytes (5.1 MB) copied, 0.0234475 s, 218 MB/sdd if=bin/bootblock of=bin/ucore.img conv=notrunc1+0 records in1+0 records out512 bytes (512 B) copied, 0.000192811 s, 2.7 MB/sdd if=bin/kernel of=bin/ucore.img seek=1 conv=notrunc146+1 records in146+1 records out74923 bytes (75 kB) copied, 0.000295907 s, 253 MB/s\n\n根据上述的输出结果我么可以得知，在镜像生成的整个过程中主要分为三步：\n\n编译源码：gcc 命令的会对源码进行编译，如下面的命令将 kern/init/init.c 编译成目标文件 obj/kern/init/init.o：\n  + cc kern/init/init.cgcc -Ikern/init/ -fno-builtin -Wall -ggdb -m32 -gstabs -nostdinc  -fno-stack-protector -Ilibs/ -Ikern/debug/ -Ikern/driver/ -Ikern/trap/ -Ikern/mm/ -c kern/init/init.c -o obj/kern/init/init.o\n\n生成可执行文件：ld 命令将生成的目标文件进行链接生成执行文件，如下面的命令将 obj/kern 目录下的目标文件连接生成可执行文件 bin/kernel：\n  + ld bin/kernelld -m    elf_i386 -nostdlib -T tools/kernel.ld -o bin/kernel  obj/kern/init/init.o obj/kern/libs/readline.o obj/kern/libs/stdio.o obj/kern/debug/kdebug.o obj/kern/debug/kmonitor.o obj/kern/debug/panic.o obj/kern/driver/clock.o obj/kern/driver/console.o obj/kern/driver/intr.o obj/kern/driver/picirq.o obj/kern/trap/trap.o obj/kern/trap/trapentry.o obj/kern/trap/vectors.o obj/kern/mm/pmm.o  obj/libs/printfmt.o obj/libs/string.o\n\n生成镜像文件：dd 命令的作用是用指定大小的块拷贝一个文件，并在拷贝的同时进行指定的转换，下面的命令会创建一个 bin/ucore.img 文件，并将之前生成的 bin/bootblock 和 bin/kernel 拷贝到 bin/ucore.img 文件中。\n  dd if=/dev/zero of=bin/ucore.img count=1000010000+0 records in10000+0 records out5120000 bytes (5.1 MB) copied, 0.0234475 s, 218 MB/sdd if=bin/bootblock of=bin/ucore.img conv=notrunc1+0 records in1+0 records out512 bytes (512 B) copied, 0.000192811 s, 2.7 MB/sdd if=bin/kernel of=bin/ucore.img seek=1 conv=notrunc146+1 records in146+1 records out74923 bytes (75 kB) copied, 0.000295907 s, 253 MB/s\n\n问题 2：一个被系统认为是符合规范的硬盘主引导扇区的特征是什么？引导扇区的大小为 512 字节，位于磁盘的第一个扇区，但是不是所有的磁盘都装有操作系统，所以统一规定将这 512 个字节的最后两个字节设置为标志位，取固定值 0x55 和 0xAA。\n\n从实验文档中可以得知，bin/sign 是用来生硬盘主引导扇区的程序, 它的源码位于 tools/sigh.c ,内容如下：\n\n#include &lt;stdio.h&gt;#include &lt;errno.h&gt;#include &lt;string.h&gt;#include &lt;sys/stat.h&gt;intmain(int argc, char *argv[]) &#123;    struct stat st;    if (argc != 3) &#123;        fprintf(stderr, &quot;Usage: &lt;input filename&gt; &lt;output filename&gt;\\n&quot;);        return -1;    &#125;    if (stat(argv[1], &amp;st) != 0) &#123;        fprintf(stderr, &quot;Error opening file &#x27;%s&#x27;: %s\\n&quot;, argv[1], strerror(errno));        return -1;    &#125;    printf(&quot;&#x27;%s&#x27; size: %lld bytes\\n&quot;, argv[1], (long long)st.st_size);    if (st.st_size &gt; 510) &#123;        fprintf(stderr, &quot;%lld &gt;&gt; 510!!\\n&quot;, (long long)st.st_size);        return -1;    &#125;    char buf[512];    memset(buf, 0, sizeof(buf));    FILE *ifp = fopen(argv[1], &quot;rb&quot;);    int size = fread(buf, 1, st.st_size, ifp);    if (size != st.st_size) &#123;        fprintf(stderr, &quot;read &#x27;%s&#x27; error, size is %d.\\n&quot;, argv[1], size);        return -1;    &#125;    fclose(ifp);    buf[510] = 0x55;    buf[511] = 0xAA;    FILE *ofp = fopen(argv[2], &quot;wb+&quot;);    size = fwrite(buf, 1, 512, ofp);    if (size != 512) &#123;        fprintf(stderr, &quot;write &#x27;%s&#x27; error, size is %d.\\n&quot;, argv[2], size);        return -1;    &#125;    fclose(ofp);    printf(&quot;build 512 bytes boot sector: &#x27;%s&#x27; success!\\n&quot;, argv[2]);    return 0;&#125;\n\n从源码中可以看到将 512 个字节数据中的最后两个字节分别设置为了 0x55 和 0xAA。\nbuf[510] = 0x55;buf[511] = 0xAA;\n\n练习 2\n为了熟悉使用 qemu 和 gdb 进行的调试工作，我们进行如下的小练习：\n\n从 CPU 加电后执行的第一条指令开始，单步跟踪 BIOS 的执行。\n在初始化位置 0 x 7 c 00 设置实地址断点, 测试断点正常。\n从 0 x 7 c 00 开始跟踪代码运行, 将单步跟踪反汇编得到的代码与 bootasm. S 和 bootblock. asm 进行比较。\n自己找一个 bootloader 或内核中的代码位置，设置断点并进行测试。\n\n提示：参考附录“启动后第一条执行的指令”，可了解更详细的解释，以及如何单步调试和查看 BIOS 代码。\n提示：查看 labcodes_answer&#x2F;lab 1_result&#x2F;tools&#x2F;lab 1 init 文件，用如下命令试试如何调试 bootloader 第一条指令：\n $ cd labcodes_answer&#x2F;lab 1_result&#x2F; $ make lab 1-mon\n\n问题 1：从 CPU 加电后执行的第一条指令开始，单步跟踪 BIOS 的执行在项目目录下执行 make gdb 命令，可以看到启动了一个 QEMU 虚拟机，此时它正等待着 gdb 远程连接。\n\n接下来使用 gdb 命令进行调试，输入 set architecture i8086 设置当前调试的机器为 i8086，输入 target remote : 1234 连接到 QEMU。\n\n此时输入 si 则会开始执行一条命令。\n\n问题 2：在初始化位置 0x7c00 设置实地址断点, 测试断点正常每次进行调试时都进行连接是比较麻烦的，可以将一些前置命令放在一个文件里，如下面的文件 gdbinit，每次使用 gdb -x gdbinit 命令启动 gdb，那么文件 gdbinit 中所用的命令都会被执行，之后都通过这种方式来执行。\n\n\n在 gdbinit 文件中输入如下内容，再次进行调试：\nset architecture i8086target remote:1234b *0x7c00 #设置点c     x/10i $pc #显示汇编指令\n\n\n问题 3：从 0x7c00 开始跟踪代码运行，将单步跟踪反汇编得到的代码与 bootasm.S 和 bootblock.asm 进行比较bootasm.S 和 bootblock.asm 中的内容如下，比较可知两者与 0x7c00 处的指令基本一致。\n\n\n问题 4：自己找一个 bootloader 或内核中的代码位置，设置断点并进行测试这里选择使用 kern/init/init.c 中的 kern_init 函数作为断点：\n\n将 gdbinit 文件修改为：\nset architecture i8086file bin/kerneltarget remote:1234b kern_init #设置点c     x/10i $pc #显示汇编指令\n\n获得断点处的指令如下：\n\n如果执行命令的时候使用 gdb -x gdbinit -tui，甚至可以打开一个 gdb 的命令行界面，直接现实断点处的源码文件。\n\n练习 3\nBIOS 将通过读取硬盘主引导扇区到内存，并转跳到对应内存中的位置执行 bootloader。请分析 bootloader 是如何完成从实模式进入保护模式的。\n提示：需要阅读小节“保护模式和分段机制”和 lab1&#x2F;boot&#x2F;bootasm.S 源码，了解如何从实模式切换到保护模式，需要了解：\n\n为何开启 A20，以及如何开启 A20\n如何初始化 GDT 表\n如何使能和进入保护模式\n\n\n问题 1：为何开启 A20，以及如何开启 A20当 A20 处于关闭状态时，第 21 一根地址总线的值总是 0，会导致只能访问到 0-1M, 2-3M, 4-5M 等奇数内存，所以想要访问完整的内存空间，必须开启 A20。\n根据提示阅读 lab1/boot/bootasm.S（ucore实验：bootasm.S源码），其中开启 A20 的代码如下，在 ucore 实验中通过控制键盘控制器实现 A20 的开启。\nseta20.1:    inb $0x64, %al           # 从0x64端口读取键盘控制器状态到al寄存器中    testb $0x2, %al          # 判断al寄存器第2为是否为1，如果是执行下一条指令    jnz seta20.1             # 跳转到seta20.1重新执行    movb $0xd1, %al          # 设置al寄存器的值为 0xd1    outb %al, $0x64          # 将al中的值写入0x64端口seta20.2:    inb $0x64, %al            # 从0x64端口读取键盘控制器状态到al寄存器中    testb $0x2, %al           # 判断al寄存器第2为是否为1，如果是执行下一条指令    jnz seta20.2              # 跳转到seta20.2重新执行    movb $0xdf, %al           # 设置al寄存器的值为 0xdf    outb %al, $0x60           # 将al中的值写入0x60端口\n\n所以开启 A20 的整个步骤为：\n\n向键盘控制器的 0x64 端口发送的命令 0xd1，即代码段 seta20.1 完成的工作；\n向键盘控制器的 0x60 端口发送的命令 0xdf，即代码段 seta20.2 完成的工作；\n\n问题 2：如何初始化 GDT 表 lab1/boot/bootasm.S 文件尾部定义 GDT 表，代码如下：\n# Bootstrap GDT.p2align 2                                  # force 4 byte alignmentgdt:    SEG_NULLASM                             # null seg    SEG_ASM(STA_X|STA_R, 0x0, 0xffffffff)   # code seg for bootloader and kernel    SEG_ASM(STA_W, 0x0, 0xffffffff)         # data seg for bootloader and kernelgdtdesc:    .word 0x17                              # sizeof(gdt) - 1    .long gdt                               # address gdt\n\n其中 gdtdesc 记录了 gdt 表的长度以及所在的位置，在 lab1/boot/bootasm.S 中有这么一条指令，它的作用是将 gdtdesc 处的数据读取到全局描述符表寄存器 GDTR，这是一个长度为 48 位的寄存器，计算机根据 GDTR 可以知道全局描述符表所在的位置上和长度。\nlgdt gdtdesc\n\n问题 3：如何使能和进入保护模式\n在 CPU 中有一个 CR0 寄存器，包含了 6 个预定义标志，第 0 位是保护允许位 PE ( Protedted Enable )，用于启动保护模式，如果 PE 位置 1，则保护模式启动，如果 PE&#x3D;0，则在实模式下运行。所以启动保护模式只需要将 CR0 寄存器第 0 位设为 1 即可，相关代码如下：\nmovl %cr0, %eaxorl $CR0_PE_ON, %eaxmovl %eax, %cr0\n\n练习 4\n通过阅读 bootmain.c，了解 bootloader 如何加载 ELF 文件。通过分析源代码和通过 qemu 来运行并调试 bootloader&amp;OS，\n\nbootloader 如何读取硬盘扇区的？\nbootloader 是如何加载 ELF 格式的 OS？\n\n\n问题 1：bootloader 如何读取硬盘扇区的bootmain.c 中有如下代码片段，作用就是从磁盘中读取扇区，整个流程大致为：\n\n等待磁盘准备好\n发出读取扇区的命令\n等待磁盘准备好\n把磁盘扇区数据读到指定内存\n\n// 不断的读取磁盘状态，等待磁盘准备好static void waitdisk(void)&#123;    while ((inb(0x1F7) &amp; 0xC0) != 0x40)&#125;// 读取secno处一个扇区到dst处static void readsect(void *dst, uint32_t secno)&#123;    // 等待磁盘准备好    waitdisk();    // 像磁盘中的寄存器写入要读取的扇区总数，这里始终为1    outb(0x1F2, 1);    // 写入secno    outb(0x1F3, secno &amp; 0xFF);    outb(0x1F4, (secno &gt;&gt; 8) &amp; 0xFF);    outb(0x1F5, (secno &gt;&gt; 16) &amp; 0xFF);    outb(0x1F6, ((secno &gt;&gt; 24) &amp; 0xF) | 0xE0);    // 发起读命令    outb(0x1F7, 0x20); // cmd 0x20 - read sectors    // 等待磁盘准备好    waitdisk();    // 读取数据    insl(0x1F0, dst, SECTSIZE / 4);&#125;\n\n问题 2：bootloader 是如何加载 ELF 格式的 OS下面是 bootloader 中加载 os 的代码，主要步骤是将 ELF 文件头部读到内存中，根据头部获取其他段的位置和长度，并读取到内存指定位置，之后开始执行入口函数，操作系统正式被运行起来。\nvoid bootmain(void)&#123;    // 将操作系统第一页读取到内存中，位置在ELFHDR处,    // SECTSIZE * 8 其中 SECTSIZE 大小为512字节一个扇区，8个扇区组成一页    readseg((uintptr_t)ELFHDR, SECTSIZE * 8, 0);    // 判断读取到的数据是否为一个合法的ELF，主要根据ELF头部判断    if (ELFHDR-&gt;e_magic != ELF_MAGIC)    &#123;        goto bad;    &#125;    struct proghdr *ph, *eph;    // 根据ELF头部的信息，将剩余部分读到内存中    ph = (struct proghdr *)((uintptr_t)ELFHDR + ELFHDR-&gt;e_phoff);    eph = ph + ELFHDR-&gt;e_phnum;    for (; ph &lt; eph; ph++)    &#123;        readseg(ph-&gt;p_va &amp; 0xFFFFFF, ph-&gt;p_memsz, ph-&gt;p_offset);    &#125;    // 根据ELF头部信息，执行入口函数    ((void (*)(void))(ELFHDR-&gt;e_entry &amp; 0xFFFFFF))();bad:    outw(0x8A00, 0x8A00);    outw(0x8A00, 0x8E00);    /* do nothing */    while (1)        ;&#125;\n\nucore操作系统实验-lab1-练习5\n参考资料\nLab_1：练习1——理解通过make生成执行文件的过程 - chuyaoxin - 博客园\nLab1：练习3——分析bootloader进入保护模式的过程 - huilinmumu - 博客园\n保护模式和分段机制 · ucore_os_docs\n\n","categories":["ucore操作系统实验"],"tags":["操作系统"]},{"title":"MySQL相关知识.md","url":"/2023/04/28/MySQL%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/","content":"change 和 modify 之间的区别两者使用方式如下：\nalter table &lt;表名&gt; change &lt;旧列名&gt; &lt;新列名&gt; &lt;类型&gt;alter table &lt;表名&gt; modify &lt;列名&gt; &lt;类型&gt;\n\n区别在于：\n\nchange：可以同时修改列名和列的类型\nmodify：只能用于修改列额类型\n\n"},{"title":"计算机中的路由表.md","url":"/2022/07/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%AD%E7%9A%84%E8%B7%AF%E7%94%B1%E8%A1%A8/","content":"计算机中有时候会有多个网卡，例如下面的图中所示的那样，其中 WIFI 这个网卡连接者公网，virtualBox 是虚拟机提供的虚拟网卡。\n\n那么当我们访问某个 ip 时，面对这么多的网卡，计算机使用哪个发送数据呢？其实原理很简单，计算机本地维护了一个路由表，类似于路由器维护的路由表，根据路由表中配置的规则计算机可以判断走哪个网卡。任何操作系统的计算机只要支持 TCP/IP 协议那么内部都会维护一个路由表，访问 IP 之前会先在本地路由表中查找下是否有直接的路由关系，如果有则走这个网卡，如果没有则走默认网卡。在 windows 环境下使用 route print 命令可以查看当前计算机中的路由表：\n\n接口信息展示了计算机中所有的网卡，路由表中展示的就是转发规则。\n路由表中第一行网络地址为 0.0.0.0，掩码为 0.0.0.0 表示这是一个默认路由地址，对应的网关为 10.49.0.1, 网卡地址为 10.49.255.9。默认路由则表示如果一个 IP 地址不在下面的路由规则中，则从这个网卡发出。当计算机中有两个默认路由时，计算机会选择跃点数小的那个。\n"},{"title":"SpringMVC配置.md","url":"/2023/04/09/SpringMVC%E9%85%8D%E7%BD%AE/","content":"引入 SpringMVC通过 web. xml 中引入SpringMVC 是以 DispatcherServlet 类为入口的，该类本质上也是一个 Servlet，所以配置方式和普通的 Servlet 差不多。\n&lt;web-app&gt;    &lt;listener&gt;        &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;    &lt;/listener&gt;    &lt;context-param&gt;        &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;        &lt;param-value&gt;/WEB-INF/app-context.xml&lt;/param-value&gt;    &lt;/context-param&gt;    &lt;servlet&gt;        &lt;servlet-name&gt;app&lt;/servlet-name&gt;        &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;        &lt;init-param&gt;            &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;            &lt;param-value&gt;&lt;/param-value&gt;        &lt;/init-param&gt;        &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;    &lt;/servlet&gt;    &lt;servlet-mapping&gt;        &lt;servlet-name&gt;app&lt;/servlet-name&gt;        &lt;url-pattern&gt;/app/*&lt;/url-pattern&gt;    &lt;/servlet-mapping&gt;&lt;/web-app&gt;\n\n\n监听器 org.springframework.web.context.ContextLoaderListener 的作用就是启动 Web 容器时自动装配 ApplicationContext，这里指的就是 Spring 容器。因为它实现了 ServletContextListener 这个接口，服务器启动容器时，就会默认执行它实现的方法。ApplicationContext  配置文件的默认路径是 /WEB-INF/applicationContext. xml，在 WEB-INF 目录下创建的 xml 文件的名称必须是 applicationContext. xml。如果是要自定义文件名可以在 web. xml 里加入 contextConfigLocation 这个参数。如果有多个 xml 文件，可以写在一起并以“,”号分隔，也可以这样 applicationContext-*. xml 采用通配符。\n使用 Spring MVC，配置 DispatcherServlet 是第一步。DispatcherServlet 是一个 Servlet，所以可以配置多个 DispatcherServlet。这个 Servlet 用于拦击请求，使请求进入到 SpringMVC 中的逻辑中，它还会引入一个 SpringMVC 容器，该容器配置文件的默认路径为 /WEB-INF/&lt;servlet-name&gt;-servlet.xml，如果自定义配置文件位置的话，和 Spring 容器是一样的。\n\nJava 配置引入在 Servlet 3 规范中允许使用 Java 类来代替 web.xml 文件进行配置，具体方式是创建一个 AbstractAnnotationConfigDispatcherServletInitializer 的子类。\npublic class MyWebInitializer extends AbstractAnnotationConfigDispatcherServletInitializer &#123;        @Override      protected String[] getServletMappings() &#123;          return new String[] &#123; &quot;/&quot; &#125;;      &#125;        @Override      protected Class&lt;?&gt;[] getRootConfigClasses() &#123;          return new Class&lt;?&gt;[] &#123; RootConfig.class &#125;;      &#125;        @Override      protected Class&lt;?&gt;[] getServletConfigClasses() &#123;          return new Class&lt;?&gt;[] &#123; WebConfig.class &#125;;      &#125;    &#125;\n\n\ngetRootConfigClasses() 返回根容器的 Java 配置文件，对应到 web. xml 就是 contextConfigLocation 配置的 xml 文件；\n  &lt;listener&gt;        &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;&lt;/listener&gt;&lt;context-param&gt;    &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;    &lt;param-value&gt;/WEB-INF/app-context.xml&lt;/param-value&gt;&lt;/context-param&gt;\n\ngetServletConfigClasses() 返回的就是 DispatcherServlet 中容器的 Java 配置文件；\n\ngetServletMappings​() 返回的是 DispatcherServlet 要处理的路径。\n\n\nJavap 类配置的原理是在 Servlet 3.0 环境中，容器会在类路径中查找实现 javax.servlet.ServletContainerInitializer 接口的类，如果能发现的话，就会用它来配置 Servlet 容器。Spring 提供了这个接口的实现，名为 SpringServletContainerInitializer，这个类反过来又会查找实现 WebApplicationInitializer 的类并将配置的任务交给它们来完成。Spring 3.2 引入了一个便利的 WebApplicationInitializer 基础实现，也就是 AbstractAnnotationConfigDispatcherServletInitializer。\n如果想对 DispatcherServlet 进行更丰富的设置，可以通过重写 customizeRegistration 方法来实现，如下面设置了上传文件时的临时文件夹。\n@Overrideprotected void customizeRegistration(Dynamic registration) &#123;      registration.setMultipartConfig(              new MultipartConfigElement(&quot;/tmp/spittr/uploads&quot;);      );  &#125;\n\n容器配置无论是使用 xml 还是使用 Java 类进行配值，两个容器本质上还是 Spring 容器，所以配置上是一样的。不同的地方在于 DispatcherServlet ​ 创建的容器中会使用一些特殊的 Bean，这些 Bean​ 是 SpringMVC​ 的一部分，如映射器、视图解析器之类。\n@Configuration@EnableWebMvcpublic class WebConfig &#123;&#125;\n\n在 SpringMVC 的配置文件中，可以添加 @EnableWebMvc 注解，它的主要作用是向容器中添加默认的 Bean，例如默认的试图解析器 BeanNameViewResolver。\nurl-pattern 配置这部分属于 web 容器的配置，主要是决定哪些 url 请求转发给 SpringMVC 来处理。Servlet 中 url-pattern​ 有三种匹配模式：精确匹配、路径匹配和后缀匹配，三种匹配模式的优先级也依次降低。\n精确匹配&lt;servlet-mapping&gt;    &lt;servlet-name&gt;MyServlet&lt;/servlet-name&gt;    &lt;url-pattern&gt;/user&lt;/url-pattern&gt;&lt;/servlet-mapping&gt;\n\n上面的配置只能匹配：\nhttp://localhost:8080/appDemo/user​ \n\n路径匹配以 / ​ 开头以 /* 结尾的都属于路径匹配。\n&lt;servlet-mapping&gt;    &lt;servlet-name&gt;MyServlet&lt;/servlet-name&gt;    &lt;url-pattern&gt;/user/*&lt;/url-pattern&gt;&lt;/servlet-mapping&gt;\n\n上面的 servlet​ 可以匹配如下路径：\nhttp://localhost:8080/appDemo/user/users.htmlhttp://localhost:8080/appDemo/user/addUser.actionhttp://localhost:8080/appDemo/user/updateUser.actionl\n\n后缀匹配以 *. ​ 开头的属于后缀匹配，需要注意的是路径和后缀不能同时设置。\n&lt;servlet-mapping&gt;    &lt;servlet-name&gt;MyServlet&lt;/servlet-name&gt;    &lt;url-pattern&gt;*.jsp&lt;/url-pattern&gt;    &lt;url-pattern&gt;*.action&lt;/url-pattern&gt;&lt;/servlet-mapping&gt;\n\n上面的 servlet​ 可以匹配如下路径：\nhttp://localhost:8080/appDemo/user/users.jsphttp://localhost:8080/appDemo/toHome.action\n\n/ 和 /* 的区别当其他 servlet​ 无法匹配时，会匹配到 url-pattern​ 设置为 / 的 servlet​，/* 属于路径匹配，可以用来匹配任何路径。\ntomcat 中的默认配置​tomcat​ 默认配置了两个 servlet​，如下所示：\n&lt;servlet-mapping&gt;    &lt;servlet-name&gt;default&lt;/servlet-name&gt;    &lt;url-pattern&gt;/&lt;/url-pattern&gt;&lt;/servlet-mapping&gt;&lt;!-- The mappings for the JSP servlet --&gt;&lt;servlet-mapping&gt;    &lt;servlet-name&gt;jsp&lt;/servlet-name&gt;    &lt;url-pattern&gt;*.jsp&lt;/url-pattern&gt;    &lt;url-pattern&gt;*.jspx&lt;/url-pattern&gt;&lt;/servlet-mapping&gt;\n\nwelcome-file-list​web.xml​ 中有如下设置，用于配置欢迎页面，当用户在 url​ 中输入工程名称或者输入 web​ 容器 url​ 如 http://localhost:8080/​ 时直接跳转到 welcome-file-list​ 设置的路径。\n&lt;welcome-file-list&gt;    &lt;welcome-file&gt;index.html&lt;/welcome-file&gt;    &lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt;    &lt;welcome-file&gt;index.action&lt;/welcome-file&gt;&lt;/welcome-file-list&gt;\n\nSpringMVC 配置WebMvcConfigurer 配置在 java​ 配置中需要使用 @EnableWebMvc​ 注解来开启 MVC​ 配置，而在 XML​ 配置中需要使用 mvc:annotation-driven/​，它们默认会导入一些类。\n@Configuration@EnableWebMvcpublic class WebConfig &#123;  &#125;\n\n使用 java​ 代码进行配置需要编写 WebMvcConfigurer​ 实现类，XML​ 中可以使用 mvc:annotation-driven/​ 的属性和子元素进行配置。\n@Configuration@EnableWebMvcpublic class WebConfig implements WebMvcConfigurer &#123;    // Implement configuration methods...&#125;\n\n类型转化默认情况下，SpringMVC​ 安装了 Number​ 和 Date​ 类型的格式化程序，包括对 @NumberFormat​ 和 @DateTimeFormat​ 注解的支持。如果 Classpath​ 中存在 Joda-Time​，则还将安装对 Joda-Time​ 格式库的完全支持。\n@Configuration@EnableWebMvcpublic class WebConfig implements WebMvcConfigurer &#123;    @Override    public void addFormatters(FormatterRegistry registry) &#123;        // ...    &#125;&#125;\n\n数据校验默认情况下，如果 Bean Validation​ 存在于 Classpath​ 中，例如 Hibernate Validator​，则 LocalValidatorFactoryBean​ 被注册为全局 Validator​，以便与控制器方法参数上的 @Valid​ 和 Validated​ 一起使用。在 Java​ 配置中，可以自定义全局 Validator​ 实例：\n@Configuration@EnableWebMvcpublic class WebConfig implements WebMvcConfigurer &#123;    @Override    public Validator getValidator(); &#123;        // ...    &#125;&#125;\n\n还可以在本地添加校验器。\n@Controllerpublic class MyController &#123;    @InitBinder    protected void initBinder(WebDataBinder binder) &#123;        binder.addValidators(new FooValidator());    &#125;&#125;\n\n拦截器拦截器的作用是在 Controller 处理请求之前拦截请求进行一些处理。\n@Configuration@EnableWebMvcpublic class WebConfig implements WebMvcConfigurer &#123;    @Override    public void addInterceptors(InterceptorRegistry registry) &#123;        registry.addInterceptor(new LocaleChangeInterceptor());        registry.addInterceptor(new ThemeChangeInterceptor()).addPathPatterns(&quot;/**&quot;).excludePathPatterns(&quot;/admin/**&quot;);        registry.addInterceptor(new SecurityInterceptor()).addPathPatterns(&quot;/secure/*&quot;);    &#125;&#125;\n\n消息转换器下图展示了消息转换器的作用，主要是把 http 请求中的信息转化为 Java 对象，或者把 Java 对象转化为相应数据如 Json 之类的。\n\n@Configuration@EnableWebMvcpublic class WebConfiguration implements WebMvcConfigurer &#123;    @Override    public void configureMessageConverters(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters) &#123;        Jackson2ObjectMapperBuilder builder = new Jackson2ObjectMapperBuilder()                .indentOutput(true)                .dateFormat(new SimpleDateFormat(&quot;yyyy-MM-dd&quot;))                .modulesToInstall(new ParameterNamesModule());        converters.add(new MappingJackson2HttpMessageConverter(builder.build()));        converters.add(new MappingJackson2XmlHttpMessageConverter(builder.createXmlMapper(true).build()));    &#125;&#125;\n\n查看控制器@Configuration@EnableWebMvcpublic class WebConfig implements WebMvcConfigurer &#123;    @Override    public void addViewControllers(ViewControllerRegistry registry) &#123;        registry.addViewController(&quot;/&quot;).setViewName(&quot;home&quot;);    &#125;&#125;\n\n&lt;mvc:view-controller path=&quot;/&quot; view-name=&quot;home&quot;/&gt;\n\n视图解析器@Configuration@EnableWebMvcpublic class WebConfig implements WebMvcConfigurer &#123;    @Override    public void configureViewResolvers(ViewResolverRegistry registry) &#123;        registry.enableContentNegotiation(new MappingJackson2JsonView());        registry.jsp();    &#125;&#125;\n\n静态资源处理@Configuration@EnableWebMvcpublic class WebConfig implements WebMvcConfigurer &#123;    @Override    public void addResourceHandlers(ResourceHandlerRegistry registry) &#123;        registry.addResourceHandler(&quot;/resources/**&quot;)            .addResourceLocations(&quot;/public&quot;, &quot;classpath:/static/&quot;)            .setCachePeriod(31556926);    &#125;&#125;\n\n默认 servlet​SpringMVC​ 中没有做出映射的请求，交给容器默认的 Servlet​ 去处理。\n@Configuration@EnableWebMvcpublic class WebConfig implements WebMvcConfigurer &#123;    @Override    public void configureDefaultServletHandling(DefaultServletHandlerConfigurer configurer) &#123;        configurer.enable();    &#125;&#125;\n\n请求映射@RequestMapping​​@RequestMapping​ 用来将请映射到控制器方法，SpringMVC​ 中还提供了下面的注解来指定特定的 http​ 请求。\n\n​@GetMapping​\n​@PostMapping​\n​@PutMapping​\n​@DeleteMapping​\n​@PatchMapping​\n\n@RestController@RequestMapping(&quot;/persons&quot;)class PersonController &#123;    @GetMapping(&quot;/user&quot;)    public Person getPerson(@PathVariable Long id) &#123;        // ...    &#125;&#125;\n\n上面的例子中，&#x2F;persons&#x2F;user​ 请求会进入到 getPerson​ 方法中进行处理。\n​@RequestMapping​ 中的路径可以使用以下 glob​ 模式和通配符来映射请求：\n\n​?​ 匹配一个字符，如 &#x2F;a?b​ 可以用来匹配 &#x2F;abc​ 和 &#x2F;avc​\n​* 匹配路径段中的零个或多个字符，如 &#x2F;a&#x2F; * &#x2F;c​ 可以用来匹配 &#x2F;a&#x2F;b&#x2F;c​\n​** ​ 匹配零个或多个路径段，如 &#x2F;a&#x2F; ** &#x2F;d​ 可以用来匹配 &#x2F;a&#x2F;b&#x2F;c&#x2F;d​\n\nContent-Type 属性通过 consumes​ 属性指定提交内容 Content-Type​ 缩小映射范围。\n@PostMapping(path = &quot;/pets&quot;, consumes = &quot;application/json&quot;)public void addPet(@RequestBody Pet pet) &#123;    // ...&#125;\n\n​!​ 表示非的含义，下面例子中的方法接收 Content-Type​ 不是 application&#x2F;json​ 的 POST​ 请求。\n@PostMapping(path = &quot;/pets&quot;, consumes = &quot;!application/json&quot;) public void addPet(@RequestBody Pet pet) &#123;    // ...&#125;\n\n​produces​ 和 consumes​ 差不多，不同的地方在于前者对应的 Accept​，即响应内容 Content-Type​。\n@GetMapping(path = &quot;/pets/&#123;petId&#125;&quot;, produces = &quot;application/json;charset=UTF-8&quot;) (1)@ResponseBodypublic Pet getPet(@PathVariable String petId) &#123;    // ...&#125;\n\nParmes 和 Header 属性可以使用请求参数条件或者 header​ 条件来缩小映射范围。\n@GetMapping(path = &quot;/pets/&#123;petId&#125;&quot;, params = &quot;myParam=myValue&quot;)public void findPet(@PathVariable String petId) &#123;    // ...&#125;\n\n@GetMapping(path = &quot;/pets&quot;, headers = &quot;myHeader=myValue&quot;)public void findPet(@PathVariable String petId) &#123;    // ...&#125;\n\n参数绑定简单使用默认支持的类型在 Controller​ 方法形参中可以随时添加如下类型的参数，处理适配器会自动识别并进行赋值\n\n​HttpServletRequest​：通过 request​ 对象获取请求信息\n​HttpServletResponse​：通过 response​ 处理响应信息\n​HttpSession​：通过 session​ 对象得到 session​ 中存放的对象\n​InputStream​\n​OutputStream​\n​Reader​\n​Writer​\n​Model&#x2F;ModelAndView​\n\n简单数据类型简单参数类型指的是 java​ 内置的八种基本类型及其对应的封装类（如 StringBuffer​ 等），假设请求的 url​ 如下：\nhttp://localhost:8080/admin/login?username=123&amp;password=123\n\n\n如果 http​ 请求参数的 key​ 和 Controller​ 方法的形参名称一致时，所有的参数都会被 SpringMVC​ 会直接进行赋值。\n\n@PostMapping(&#123;&quot;/admin&quot;, &quot;/admin/login&quot;&#125;)public String login(String username, String password) &#123;      return &quot;&quot;&#125;\n\n\n当请求参数的 key​ 和 Controller​ 方法的形参名称不一致时，需要使用 @RequestParam​ 注解才能将请求参数绑定成功。\n\n@PostMapping(&#123;&quot;/admin&quot;, &quot;/admin/login&quot;&#125;)public String login(@RequestParam(&quot;username&quot;) String name, String password) &#123;      return &quot;&quot;&#125;\n\nJavaBean当控制器方法中的参数是对象时，对象中和参数名一致的所有属性会被赋值，假设请求的 url​ 为如下内容：\nhttp://localhost:8080/param/bindPojo?id=3&amp;name=小米&amp;price=3760\n\n@RequestMapping(value = &quot;bindPojo&quot;)public Item bindPojo(Item item) &#123;    return item;&#125;class Item &#123;    private String id;     private String name;     private String price; &#125;\n\n包装类包装类本身也是 javabean​，只是它的内部包含了其他的 javabean​，比如下面的 Order​ 类：\nclass Order &#123;    private String id;    private Book book;&#125;class Book &#123;    private String name;&#125;\n\n包装类内部的普通属性和 javabean​ 类的要求是一样的，内部 javabean​ 属性绑定时，需要使用如下形式：\nhttp://localhost:8080/param/bindPojo?book.name=name\n\n数组请求中有多个名称相同的参数，可以使用数组类型进行接收。\nhttp://localhost:8080/param/simpleArray?ids=1&amp;ids=2&amp;ids=3&amp;ids=4\n\n@RequestMapping(value = &quot;simpleArray&quot;)public String[] simpleArray(String[] ids) &#123;    return ids;&#125;\n\nList​List​ 不能直接放在参数列表中使用，必须放在实体类中作为属性。\nclass Order &#123;    private String id;    private List&lt;Book&gt; books;&#125;class Book &#123;    private String name;&#125;\n\n请求提交时的 key​ 对应为 books[0].name​、books[0].name​。\nMap和 List​ 一样，Map​ 也必须放在实体类中，请求时对应的 key​ 为 books[“key”].name​。\n@PathVariable可以用来将路径中带的值绑定到控制器方法的参数中，假如下面的方法接收的请求是 &#x2F;owners&#x2F;1&#x2F;pets&#x2F;2​，那么 findPet​ 方法中的两个参数分别会被传入 1​ 和 2​。默认情况下只支持简单类型的传递 (int​，long​，Date​ 等)，如果需要支持其他类型，可以配置类型转换器和数据绑定器。\n@GetMapping(&quot;/owners/&#123;ownerId&#125;/pets/&#123;petId&#125;&quot;)public Pet findPet(@PathVariable Long ownerId, @PathVariable Long petId) &#123;    // ...&#125;\n\n这个注解还支持使用正则表达式：\n@GetMapping(&quot;/&#123;name:[a-z-]+&#125;-&#123;version:\\\\d\\\\.\\\\d\\\\.\\\\d&#125;&#123;ext:\\\\.[a-z]+&#125;&quot;)public void handle(@PathVariable String version, @PathVariable String ext) &#123;    // ...&#125;\n\n@RequestParam将请求参数 (即查询参数或表单数据) 绑定到控制器中的方法参数。\n@Controller@RequestMapping(&quot;/pets&quot;)public class EditPetForm &#123;    // ...    @GetMapping    public String setupForm(@RequestParam(&quot;petId&quot;) int petId, Model model) &#123; (1)        Pet pet = this.clinic.loadPet(petId);        model.addAttribute(&quot;pet&quot;, pet);        return &quot;petForm&quot;;    &#125;    // ...&#125;\n\n默认情况下，使用此注解的方法参数是必需的，但是可以通过将 @RequestParam​ 注解的 required​ 标志设置为 false​ 或通过 java.util.Optional​ 包装器声明参数来指定方法参数是可选的。如果目标方法参数类型不是 String​，则会自动应用类型转换。将参数类型声明为数组或列表，可以为同一参数名称解析多个参数值。如果将 @RequestParam​ 注解声明为 Map&lt;String, String&gt;​ 或 MultiValueMap&lt;String, String&gt;​，而未在注解中指定参数名，则将使用每个给定参数名的请求参数值填充 Map​。\n@RequestHeader将 header​ 中的值绑定到参数。\n@GetMapping(&quot;/demo&quot;)public void handle(        @RequestHeader(&quot;Accept-Encoding&quot;) String encoding, (1)        @RequestHeader(&quot;Keep-Alive&quot;) long keepAlive) &#123; (2)    //...&#125;\n\n如果目标方法的参数类型不是 String​，则将自动应用类型转换。在 Map&lt;String, String&gt;​，MultiValueMap&lt;String, String&gt;​ 或 HttpHeaders​ 参数上使用 @RequestHeader​ Comments 时，将使用所有 Headers​ 值填充 Map​。\n@CookieValue将 Cookie​ 中的值绑定到参数。\n@GetMapping(&quot;/demo&quot;)public void handle(@CookieValue(&quot;JSESSIONID&quot;) String cookie) &#123; (1)    //...&#125;\n\n如果目标方法的参数类型不是 String​，那么将自动应用类型转换。\n@ModelAttribute\n​@ModelAttribute​ 注释 void​ 返回值的方法\n  @Controllerpublic class HelloWorldController &#123;    @ModelAttribute    public void populateModel(@RequestParam String abc, Model model) &#123;         model.addAttribute(&quot;attributeName&quot;, abc);      &#125;    @RequestMapping(value = &quot;/helloWorld&quot;)    public String helloWorld() &#123;       return &quot;helloWorld&quot;;        &#125;&#125;\n\n  这个例子，在获得请求 &#x2F;helloWorld​ 后，populateModel​ 方法在 helloWorld​ 方法之前先被调用，它把请求参数（例如 &#x2F;helloWorld?abc&#x3D;text​ 中的 abc&#x3D;text​）加入到一个名为 attributeName​ 的 model​ 属性中，在它执行后 helloWorld​ 被调用，返回视图名 helloWorld​，这里 model​ 已由 @ModelAttribute​ 方法生产好了。当请求中不包含此参数时，会报错，可以将该值设置为非必要。\n\n​@ModelAttribute​ 注释返回具体类的方法\n  @ModelAttribute public Account addAccount(@RequestParam String number) &#123;     return accountManager.findAccount(number); &#125; \n\n  这种情况 model​ 属性的名称没有指定，它由返回类型隐含表示，如这个方法返回 Account​ 类型，那么这个 model​ 属性的名称是 account​。\n\n​@ModelAttribute(value&#x3D;””)​ 注释返回具体类的方法\n  @Controllerpublic class HelloWorldController &#123;    @ModelAttribute(&quot;attributeName&quot;)    public String addAccount(@RequestParam String abc) &#123;        return abc;      &#125;    @RequestMapping(value = &quot;/helloWorld&quot;)    public String helloWorld() &#123;        return &quot;helloWorld&quot;;    &#125;&#125;\n\n  这个例子中使用 @ModelAttribute​ 注释的 value​ 属性，来指定 model​ 属性的名称，model​ 属性对象就是方法的返回值,它无须要特定的参数。\n\n​@ModelAttribute​ 和 @RequestMapping​ 同时注释一个方法\n  @Controllerpublic class HelloWorldController &#123;    @RequestMapping(value = &quot;/helloWorld.do&quot;)    @ModelAttribute(&quot;attributeName&quot;)    public String helloWorld() &#123;         return &quot;hi&quot;;    &#125;&#125;\n\n  这时这个方法的返回值并不是表示一个视图名称，而是 model​ 属性的值，视图名称由 RequestToViewNameTranslator​ 根据请求 “&#x2F;helloWorld.do”​ 转换为逻辑视图 helloWorld​。model​ 属性名称由 @ModelAttribute(value&#x3D;””)​ 指定，相当于在 request​ 中封装了 key&#x3D;attributeName​，value&#x3D;hi​。\n\n​@ModelAttribute​ 注释一个方法的参数\n  @Controllerpublic class HelloWorldController &#123;    @ModelAttribute(&quot;user&quot;)    public User addAccount() &#123;        return new User(&quot;jz&quot;,&quot;123&quot;);    &#125;    @RequestMapping(value = &quot;/helloWorld&quot;)    public String helloWorld(@ModelAttribute(&quot;user&quot;) User user) &#123;           user.setUserName(&quot;jizhou&quot;);           return &quot;helloWorld&quot;;    &#125;&#125;\n\n  在这个例子里，@ModelAttribute(“user”) ​ 注释方法参数，参数 user​ 的值来源于 addAccount()​ 方法中添加的值。\n\n\n@SessionAttributes​@SessionAttributes​ 用于在请求之间的 HTTP Servlet​ 会话中存储模型属性，它是类型级别的注解，用于声明特定控制器使用的会话属性。\n@Controller@SessionAttributes(&quot;pet&quot;) (1)public class EditPetForm &#123;    // ...    @PostMapping(&quot;/pets/&#123;id&#125;&quot;)    public String handle(Pet pet, BindingResult errors, SessionStatus status) &#123;        if (errors.hasErrors) &#123;            // ...        &#125;            status.setComplete(); (2)            // ...        &#125;    &#125;&#125;\n\n\n（1）处添加了注解之后，该类中的所有方法向 model​ 中添加 key​ 为 pet​ 的值使，将会在 Session 中存储一份存储在 Servlet 会话中。\n（2）处展示清除 Session 中设置的值。\n\n通常不推荐使用该注解，某些情况下可能会出现错误，所以推荐使用原生 api 添加。\n@SessionAttribute用于从 session​ 中获取数据。\n@RequestMapping(&quot;/&quot;)public String handle(@SessionAttribute User user) &#123; (1)    // ...&#125;\n\n@RequestAttribute类似于 @SessionAttribute​。\n@GetMapping(&quot;/&quot;)public String handle(@RequestAttribute Client client) &#123; (1)    // ...&#125;\n\n@RequestBody可以使用 @RequestBody​ 注解将请求正文读取并通过 HttpMessageConverter​ 反序列化为 Object​。\n@PostMapping(&quot;/accounts&quot;)public void handle(@RequestBody Account account) &#123;    // ...&#125;\n\nHttpEntity​HttpEntity​ 与使用 @RequestBody​ 大致相同，但是它基于一个容器对象，该对象包含了 Headers​ 和正文。\n@PostMapping(&quot;/accounts&quot;)public void handle(HttpEntity&lt;Account&gt; entity) &#123;     entity.getBody();     entity.getHeaders();&#125;\n\n@ResponseBody可以使用 @ResponseBody​ 注解将请求正文通过 HttpMessageConverter​ 序列化并发送。\n@GetMapping(&quot;/accounts/&#123;id&#125;&quot;)@ResponseBodypublic Account handle() &#123;    // ...&#125;\n\nResponseEntity与 @ResponseBody​ 类似，但可以添加状态和标题。\n@GetMapping(&quot;/something&quot;)public ResponseEntity&lt;String&gt; handle() &#123;    String body = ... ;    String etag = ... ;    return ResponseEntity.ok().eTag(etag).build(body);&#125;\n\nSpringMVC文件上传\n跨域配置@CrossOrigin该注解允许请求跨域，支持在类和方法上使用，默认情况下 @CrossOrigin​ 允许：\n\n所有 origins​\n所有 headers​\n所有 http​ 方法\n\n@RestController@RequestMapping (&quot;/account&quot;)Public class AccountController &#123;    @CrossOrigin    @GetMapping (&quot;/&#123;id&#125;&quot;)    Public Account retrieve (@PathVariable Long id) &#123;        // ...    &#125;    @DeleteMapping (&quot;/&#123;id&#125;&quot;)    Public void remove (@PathVariable Long id) &#123;        // ...    &#125;&#125;\n\n全局配置默认情况下，允许如下跨域请求：\n\n所有 origins​\n所有 headers​\n​GET​，HEAD​ 和 POST​ 方法。\n\n要修改全局配置可以使用如下 java​ 或 xml​ 方式。\n@Configuration@EnableWebMvcPublic class WebConfig implements WebMvcConfigurer &#123;    @Override    Public void addCorsMappings (CorsRegistry registry) &#123;        Registry.AddMapping (&quot;/api/**&quot;)            .allowedOrigins (&quot; http://domain2.com&quot; )            .allowedMethods (&quot;PUT&quot;, &quot;DELETE&quot;)            .allowedHeaders (&quot;header 1&quot;, &quot;header 2&quot;, &quot;header 3&quot;)            .exposedHeaders (&quot;header 1&quot;, &quot;header 2&quot;)            .allowCredentials (true). MaxAge (3600);        // Add more mappings...    &#125;&#125;\n\n&lt;mvc:cors&gt;    &lt;mvc: mapping path=&quot;/api/**&quot;        allowed-origins=&quot; http://domain1.com , http://domain2.com&quot;        Allowed-methods=&quot;GET, PUT&quot;        Allowed-headers=&quot;header 1, header 2, header 3&quot;        Exposed-headers=&quot;header 1, header 2&quot; allow-credentials=&quot;true&quot;        Max-age=&quot;123&quot; /&gt;    &lt;mvc: mapping path=&quot;/resources/**&quot;        allowed-origins=&quot; http://domain1.com&quot; /&gt;&lt;/mvc:cors&gt;\n\nCORS 过滤器还可以通过添加过滤器的方式实现跨域。\n@BeanPublic CorsFilter corsFilter () &#123;      CorsConfiguration config = new CorsConfiguration ();    // Possibly...    // config.ApplyPermitDefaultValues ()    Config.SetAllowCredentials (true);    config.AddAllowedOrigin (&quot; http://domain1.com&quot; );    Config.AddAllowedHeader (&quot;*&quot;);    Config.AddAllowedMethod (&quot;*&quot;);    UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource ();    Source.RegisterCorsConfiguration (&quot;/**&quot;, config);    CorsFilter filter = new CorsFilter (source);    Return filter;&#125;"},{"title":"vscode中的task.json和launch.json文件.md","url":"/2022/01/13/vscode%E4%B8%AD%E7%9A%84task.json%E5%92%8Claunch.json%E6%96%87%E4%BB%B6/","content":"在使用 vscode 编写项目的时候，有时候能看到一个名为 .vscode 的文件夹，这个文件夹中保存的就是跟 vscode 相关的配置文件，需要注意的是该配置文件仅对当前项目有效。其中 task.json 和 launch.json 是两个比较重要的文件，前者主要用于生成程序（如使用 gcc 命令编译源码），后者用于程序的调试。\ntask. json\n在 task.json 文件中写入如下内容：\n&#123;    &quot;tasks&quot;: [        &#123;            &quot;type&quot;: &quot;cppbuild&quot;,            &quot;label&quot;: &quot;build&quot;,            &quot;command&quot;: &quot;D:\\\\scoop\\\\apps\\\\mingw\\\\current\\\\bin\\\\gcc.exe&quot;,            &quot;args&quot;: [                &quot;-fdiagnostics-color=always&quot;,                &quot;-g&quot;,                &quot;$&#123;file&#125;&quot;,                &quot;-o&quot;,                &quot;$&#123;fileDirname&#125;\\\\$&#123;fileBasenameNoExtension&#125;.exe&quot;            ],            &quot;options&quot;: &#123;                &quot;cwd&quot;: &quot;$&#123;fileDirname&#125;&quot;            &#125;,            &quot;group&quot;: &#123;                &quot;kind&quot;: &quot;build&quot;,                &quot;isDefault&quot;: true            &#125;,            &quot;detail&quot;: &quot;调试器生成的任务。&quot;        &#125;,    ],    &quot;version&quot;: &quot;2.0.0&quot;&#125;\n\n点击 终端-&gt;运行任务-&gt;build，vscode 将会读取上述配置文件，并根据配置文件编译当前打开的文件，如 main.c。\n\n\n从终端输出的结果可以看到任务 build 执行了，并且可以看到实际执行的命令。\n\ntask.json 更详细的参数介绍, 可查看：Tasks in Visual Studio Code\nlaunch. jsonlaunch.json 可以配置调试相关的信息，我们在该文件中配置三个不同的调试配置，那么在 vscode 调试界面则可以看到我们配置。\n&#123;    &quot;version&quot;: &quot;0.2.0&quot;,    &quot;configurations&quot;: [        &#123;            &quot;name&quot;: &quot;js 调试&quot;,            &quot;program&quot;: &quot;$&#123;workspaceFolder&#125;/$&#123;fileBasename&#125;&quot;,            &quot;request&quot;: &quot;launch&quot;,            &quot;skipFiles&quot;: [                &quot;&lt;node_internals&gt;/**&quot;            ],            &quot;type&quot;: &quot;node&quot;        &#125;,        &#123;            &quot;name&quot;: &quot;python 调试&quot;,            &quot;type&quot;: &quot;python&quot;,            &quot;request&quot;: &quot;launch&quot;,            &quot;program&quot;: &quot;$&#123;file&#125;&quot;,            &quot;console&quot;: &quot;integratedTerminal&quot;,            &quot;justMyCode&quot;: true        &#125;,        &#123;            &quot;name&quot;: &quot;c 调试&quot;,            &quot;type&quot;: &quot;cppdbg&quot;,            &quot;request&quot;: &quot;launch&quot;,            &quot;program&quot;: &quot;$&#123;workspaceFolder&#125;/$&#123;fileBasenameNoExtension&#125;.exe&quot;,            &quot;args&quot;: [],            &quot;stopAtEntry&quot;: false,            &quot;cwd&quot;: &quot;$&#123;fileDirname&#125;&quot;,            &quot;environment&quot;: [],            &quot;externalConsole&quot;: false,            &quot;MIMode&quot;: &quot;gdb&quot;,            &quot;miDebuggerPath&quot;: &quot;gdb&quot;,        &#125;    ]&#125;\n\n\n使用 c 调试 则可以用来调试 cdebug.c 程序，python调试 能用来调试 pydebug.py 程序。\n\n\nlaunch.json 更详细的参数介绍可查看：Debugging in Visual Studio Code\n","categories":["vscode配置"],"tags":["vscode","工具"]},{"title":"ucore操作系统实验-lab1-练习5.md","url":"/2023/06/10/ucore%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C-lab1-%E7%BB%83%E4%B9%A05/","content":"\n我们需要在 lab1 中完成 kdebug.c 中函数 print_stackframe 的实现，可以通过函数 print_stackframe 来跟踪函数调用堆栈中记录的返回地址。在如果能够正确实现此函数，可在 lab1 中执行 “make qemu”后，在 qemu 模拟器中得到类似如下的输出：\n……ebp:0x00007b28 eip:0x00100992 args:0x00010094 0x00010094 0x00007b58 0x00100096    kern&#x2F;debug&#x2F;kdebug.c:305: print_stackframe+22ebp:0x00007b38 eip:0x00100c79 args:0x00000000 0x00000000 0x00000000 0x00007ba8    kern&#x2F;debug&#x2F;kmonitor.c:125: mon_backtrace+10ebp:0x00007b58 eip:0x00100096 args:0x00000000 0x00007b80 0xffff0000 0x00007b84    kern&#x2F;init&#x2F;init.c:48: grade_backtrace2+33ebp:0x00007b78 eip:0x001000bf args:0x00000000 0xffff0000 0x00007ba4 0x00000029    kern&#x2F;init&#x2F;init.c:53: grade_backtrace1+38ebp:0x00007b98 eip:0x001000dd args:0x00000000 0x00100000 0xffff0000 0x0000001d    kern&#x2F;init&#x2F;init.c:58: grade_backtrace0+23ebp:0x00007bb8 eip:0x00100102 args:0x0010353c 0x00103520 0x00001308 0x00000000    kern&#x2F;init&#x2F;init.c:63: grade_backtrace+34ebp:0x00007be8 eip:0x00100059 args:0x00000000 0x00000000 0x00000000 0x00007c53    kern&#x2F;init&#x2F;init.c:28: kern_init+88ebp:0x00007bf8 eip:0x00007d73 args:0xc031fcfa 0xc08ed88e 0x64e4d08e 0xfa7502a8\n\n根据输出样例，我们可以知道在 print_stackframe 要做的的是把遍历当前的函数栈，并打印每个栈中的 ebp、eip 和函数中的参数。\nvoidprint_stackframe(void) &#123;     /* LAB1 YOUR CODE : STEP 1 */     /* (1) call read_ebp() to get the value of ebp. the type is (uint32_t);      * (2) call read_eip() to get the value of eip. the type is (uint32_t);      * (3) from 0 .. STACKFRAME_DEPTH      *    (3.1) printf value of ebp, eip      *    (3.2) (uint32_t)calling arguments [0..4] = the contents in address (uint32_t)ebp +2 [0..4]      *    (3.3) cprintf(&quot;\\n&quot;);      *    (3.4) call print_debuginfo(eip-1) to print the C calling function name and line number, etc.      *    (3.5) popup a calling stackframe      *           NOTICE: the calling funciton&#x27;s return addr eip  = ss:[ebp+4]      *                   the calling funciton&#x27;s ebp = ss:[ebp]      */    // 读取ebp和eip    uint32_t ebp = read_ebp(), eip = read_eip();        int i, j;    // 遍历栈    for (i = 0; ebp != 0 &amp;&amp; i &lt; STACKFRAME_DEPTH; i ++) &#123;                // 打印 ebp eip        cprintf(&quot;ebp:0x%08x eip:0x%08x args:&quot;, ebp, eip);                // 打应参数        uint32_t *args = (uint32_t *)ebp + 2;        for (j = 0; j &lt; 4; j ++) &#123;            cprintf(&quot;0x%08x &quot;, args[j]);        &#125;        cprintf(&quot;\\n&quot;);        print_debuginfo(eip - 1);        // 切换栈信息        eip = ((uint32_t *)ebp)[1];        ebp = ((uint32_t *)ebp)[0];    &#125;&#125;","categories":["ucore操作系统实验"]},{"title":"springboot 3 自动装配方式更改.md","url":"/2023/04/25/springboot%203%20%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D%E6%96%B9%E5%BC%8F%E6%9B%B4%E6%94%B9/","content":"问题描述在开发过程中用到了 mybatis-plus，启动时爆出如下错误，因怀疑是 springboot 和 mybatis-plus 版本不兼容所致，将 springboot 从 3 版本调至了 2 版本，重启后发现正常启动。\n\n解决方法网上搜索之后返现原因是 springboot 更改了启动时的自动装配方式，在 2.7 版本就不推荐使用 spring.factories 的方式进行自动装配了，在 springboot 3 将彻底移除对 /META-INF/spring.factories 的支持。\n\n根据 springboot 2.7 的版本说明：Spring Boot 2.7 Release Notes · spring-projects&#x2F;spring-boot Wiki · GitHub，可以得知自动配置的文件被移动到了 META-INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports 中，文件格式是每行写一个自动配置类。\n\norg.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfigurationorg.springframework.boot.autoconfigure.aop.AopAutoConfigurationorg.springframework.boot.autoconfigure.amqp.RabbitAutoConfigurationorg.springframework.boot.autoconfigure.batch.BatchAutoConfigurationorg.springframework.boot.autoconfigure.cache.CacheAutoConfiguration\n\n参考资料\nspring.factories要被弃用了，快来Get新写法！-Spring专区论坛-技术干货-SpringForAll社区\n\n","categories":["问题记录"],"tags":["springboot","问题"]},{"title":"docker 常用操作.md","url":"/2023/04/18/docker%20%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/","content":"镜像操作获取镜像docker pull [选项] [Docker Registry 地址[:端口号]/]仓库名[:标签]\n\n\nDocker 镜像仓库地址：格式一般是 &lt;域名/IP&gt;[:端口号]，默认地址是 Docker Hub (docker.io)；\n仓库名：格式一般为 &lt;用户名&gt;/&lt;软件名&gt;，对于 Docker Hub，如果不给出用户名，则默认为 library，也就是官方镜像。\n\n列出镜像docker image ls\n\n\n该命令会列出所有镜像的信息，包含了 仓库名、标签、镜像 ID、创建时间 以及 所占用的空间。\n查看镜像体积应为 docker 中的镜像是分层存储的，不同的镜像可能使用了同一层的内容，所以 docker 镜像占用的空间并不是上面每个镜像占用空间的简单加和，如果想要知道镜像占用的实际空间，可以使用下面的命令查看。\ndocker system df\n\n\n悬浮镜像有时候在镜像列表中会出现仓库名和标签名为 &lt;none&gt; 的镜像，这是由于新旧镜像同名，旧镜像名称被取消，像这种无标签镜像也被称为虚悬镜像，以下情况可能会出现悬浮镜像：\n\n官方对镜像进行了维护，之后使用 docker pull 拉取镜像；\n使用 docker build 命令构建了新的同名镜像。\n\nREPOSITORY      TAG           IMAGE ID         CREATED          SIZE&lt;none&gt;          &lt;none&gt;        00285df0df87     5 days ago       342 MB\n\ndocker image ls -f dangling=true  命令可以查看悬浮镜像。一般来说悬浮惊醒已经没有任何的使用价值，可以通过 docker image prune 命令进行删除。\n中间层镜像由于镜像是分层存储的，有时候拉取顶层镜像的时候会存在一些中间镜像，这些镜像不会再列表中出现，但是对于顶层镜像来说是必须的。同时因为这些中间镜像是会重复利用的，只用删除顶层镜像，它依赖的中间镜像也会被删除，所以一般情况下不必担心中间镜像占用存储空间。如果希望查看中间镜像，可以使用如下命令：\n$ docker image ls -a\n\n列出指定镜像docker image ls ubuntu\n$ REPOSITORY          TAG                 IMAGE ID            CREATED             SIZEubuntu              18.04               329ed837d508        3 days ago          63.3MBubuntu              bionic              329ed837d508        3 days ago          63.3MB\n\n$ docker image ls ubuntu:18.04REPOSITORY          TAG                 IMAGE ID            CREATED             SIZEubuntu              18.04               329ed837d508        3 days ago          63.3MB\n\n\n可以使用 --filter 过滤器，比如要查看 mongo:3.2 之后建立的镜像，可以用下面的命令：\n\n$ docker image ls -f since=mongo:3.2REPOSITORY          TAG                 IMAGE ID            CREATED             SIZEredis               latest              5f515359c7f8        5 days ago          183 MBnginx               latest              05a60462f8ba        5 days ago          181 MB\n\n想查看某个位置之前的镜像也可以，只需要把 since 换成 before 即可。此外，如果镜像构建时，定义了 LABEL，还可以通过 LABEL 来过滤。\n$ docker image ls -f label=com.example.version=0.1\n\n以特定格式显示\n只显示 id\n\n$ docker image ls -q5f515359c7f805a60462f8bafe9198c04d6200285df0df87329ed837d508329ed837d508\n\n\n自定义格式，格式使用 go 语言模板\n\n$ docker image ls --format &quot;&#123;&#123;.ID&#125;&#125;: &#123;&#123;.Repository&#125;&#125;&quot;5f515359c7f8: redis05a60462f8ba: nginxfe9198c04d62: mongo00285df0df87: &lt;none&gt;329ed837d508: ubuntu329ed837d508: ubuntu\n\n删除镜像docker image rm [选项] &lt;镜像1&gt; [&lt;镜像2&gt; ...]\n\n其中，&lt;镜像&gt; 可以是 镜像短 ID、镜像长 ID、镜像名 或者 镜像摘要，并且可以使用下面的方式配合 docker image ls 删除多个镜像。\n$ docker image rm $(docker image ls -q redis)\n\n容器操作新建并启动新建容器的命令如下，可以指定容器中执行的程序以及所需的参数。\ndocker run ubuntu:18.04 /bin/echo &#x27;Hello world&#x27;\n\n当利用 docker run 来创建容器时，Docker 在后台运行的标准操作包括：\n\n检查本地是否存在指定的镜像，不存在就从 registry 下载\n利用镜像创建并启动一个容器\n分配一个文件系统，并在只读的镜像层外面挂载一层可读写层\n从宿主主机配置的网桥接口中桥接一个虚拟接口到容器中去\n从地址池配置一个 ip 地址给容器\n执行用户指定的应用程序\n执行完毕后容器被终止\n\n如果想要和容器中运行的程序进行交互，可以使用如下命令：\ndocker run -t -i ubuntu:18.04 /bin/bashroot@af8bae53bdd3:/#\n\n\n-t 选项让 Docker 分配一个伪终端（pseudo-tty）并绑定到容器的标准输入上；\n-i 则让容器的标准输入保持打开。\n\n启动已经存在的容器docker container start\n\n后台运行\n默认情况下容器的输出会直接在前台现实，-d 参数用来让容器在后台输出。\n\n此时会返回一个 容器ID，如果想要查看容器的输出内容，可以使用 docker container logs 命令。\n\n输出内容使用 docker logs 来查看。\n$ docker run -d ubuntu:18.04 /bin/sh -c &quot;while true; do echo hello world; sleep 1; done&quot;77b2dc01fe0f3f1265df143181e7b9af5e05279a884f4776ee75350ea9d8017a\n\n终止容器docker container stop 容器ID\n\n\n终止后返回容器对应的 ID。\n列出容器docker container ls\n\n如果想要列出所有容器，可以使用 -a 参数：\ndocker container ls -a\n\n\n重启容器改命令会将一个运行态的容器终止，然后再重新启动它。\ndocker container restart 容器ID\n\n进入容器当容器后台运行时，有时候需要重新进入到容器中进行一些操作，这时候可以使用 docker exec 命令。\n首先创建一个后台运行的 ubuntu 容器。\n\n通过如下命令可以进入到该容器中进行一些操作：\ndocker exec -it d63a bash\n\n\n-t 和 -i 参数的含义和 docker run 中的参数含义是一样的。\n删除容器docker container rm 容器ID\n\n\n类似于镜像操作，使用 docker container prune 可以清理掉所有处于终止状态的容器。\n查看容器详情docker container inspect 容器ID\n\n\n数据操作数据卷容器中所有的数据的生存周期和容器是一致的，例如我们使用了一个 MySQL 容器，当移除该容器后所有存储的数据都将会消失。数据卷提供了一种将数据和容器分离的机制，类似于 Linux 中的文件挂载，数据存在于硬盘中，而硬盘和操作系统之间是相互独立了，这里的数据卷就可以看做是硬盘。\n创建数据卷docker volume create 数据卷名称\n\n\n查看数据卷docker volume ls 可以查看目前存在的所有数据卷，如果想要查看数据卷的详细信息，可以使用 docker volume inspect 数据卷名称。\n\n\n可以看到数据卷本质上就是 /var/lib/docker/volumes/ 目录下的一个文件夹。\n挂载数据卷在创建容器的时候使用 --mount 参数可以用来挂载数据卷，\n\n在挂在目录 /testdata 中创建一个文件，然后在主机目录下的 /var/lib/docker/volumes/mydata/_data 目录中可以看到文件 test.txt，即在容器中创建的那个文件。\n\n\n使用 docker container inspect 命令查看容器信息，可以在 Mounts 项中看到容器挂载的所有数据卷。\n\n删除数据卷docker volume rm 数据卷名称\n\n数据卷的存在会占用主机的存储空间，所以当数据卷不在使用时尽量将其删除，使用 $ docker volume prune 命令可以删除所有没有被挂载的数据卷。\n挂载主机目录有时候想要挂载的数据不一定是容器生成的，或者更直白的一点说，想要把主机中已经存在的数据挂载到容器上，使用 --mount 参数也是可以实现的，同时可以使用 readonly 设置为只读。\n--mount type=bind,source=/src/webapp,target=/usr/share/nginx/html,readonly \n\n网络配置端口映射容器中有时候会运行一些网络应用，如 web 服务器，那么就需要能够从外部访问到这些网络应用，在 docker 中是通过端口映射实现的。\ndocker run 命令有两个参数可以用于端口映射：\n\n-P 参数随机映射主机端口到内部容器开方的端口；\n-p 则可以指定要映射的端口，并且在一个指定端口上只可以绑定一个容器。\n\n-p 参数支持的格式有为：\nip:hostPort:containerPort | ip::containerPort | hostPort:containerPort\n\n\n-p 80:80：将所有接口上的 80 端口都映射的容器的 80 端口；\n-p 127.0.0.1:80:80：将所有接口 127.0.0.1 上的 80 端口映射的容器的 80 端口；\n-p 127.0.0.1::80：将所有接口 127.0.0.1 上的随机一个端口映射的容器的 80 端口；\n-p 127.0.0.1:80:80/udp：将所有接口 127.0.0.1 上的 80 端口映射的容器的 80 端口，不过使用的是 udp 端口。\n\n命令 docker port 可以查看映射的端口。\n\n连接容器容器互联的作用是使的同一个主机上的容器可以实现相互访问，第一步是先创建一个 docker 网络，使用的命令如下：\ndocker network create -d bridge my-net\n\n之后创建容器的时候可以使用 --network 参数指定容器使用的网络：\n\n下面使用实例展示两者之间的通信：\n\n\n其他操作容器开机自启设置容器开机自启主要有两步，设置 docker 服务开机自己，以及容器本身自动重启。在 Ubuntu 中设置 docker 自启的命令如下：\nsudo systemctl enable docker.service\n\ndocker run 命令具有参数 --restart，用于设置容器的重启策略。\n\n\n\n策略\n描述\n\n\n\nno\n默认值，不会自动重启。\n\n\non-failure\n因为错误退出就会重启，错误退出指非 0 退出码。\n\n\nalways\n停止就会重启。如果是手工停止，则在 Docker daemon 或容器本身重启时启动。\n\n\nunless-stopped\n类似于 always，除了当容器被停止，它是不会重启的。\n\n\n已经创建的容器，可以使用 docker update 命令来更新它的重启策略：\ndocker update --restart always 容器名 \n\n权限设置\n刚安装好的 docker 在使用时会提示没有权限，必须使用 sudo 来执行，解决方法为：\n\n添加 docker 用户组：sudo groupadd docker\n将当前用户添加进 docker 用户组：sudo gpasswd -a $&#123;USER&#125; docker\n重启 docekr：sudo systemctl restart docker\n修改 docker.sock 文件权限：sudo chmod a+rw /var/run/docker.sock\n\n之后再执行命令就不需要添加 sudo 了：\n\n参考资料\nDocker从入门到实践\n打不死的小强，让Docker的容器自动重启 - 南瓜慢说官网\n\n","tags":["docker"]},{"title":"MySQL操作.md","url":"/2023/04/28/MySQL%E6%93%8D%E4%BD%9C/","content":"#todo\n数据库操作\nSHOW DATABASES：用于显示当前存在的数据库。\n\n\nUSE [DATABASENAME]：切换数据库。\n\n\nSHOW TABLES：查看当前数据库中存在的表。\n\n\nSHOW COLUMNS FROM [TABLENAME]：显示某个表的表头。\n\n\n创建数据库\n\n\n删除数据库\n\n\n\n数据类型数值类型\n\n\n类型\n大小\n范围（有符号）\n范围（无符号）\n用途\n\n\n\nTINYINT\n1 byte\n(-128，127)\n(0，255)\n小整数值\n\n\nSMALLINT\n2 bytes\n(-32 768，32 767)\n(0，65 535)\n大整数值\n\n\nMEDIUMINT\n3 bytes\n(-8 388 608，8 388 607)\n(0，16 777 215)\n大整数值\n\n\nINT 或 INTEGER\n4 bytes\n(-2 147 483 648，2 147 483 647)\n(0，4 294 967 295)\n大整数值\n\n\nBIGINT\n8 bytes\n(-9,223,372,036,854,775,808，9 223 372 036 854 775 807)\n(0，18 446 744 073 709 551 615)\n极大整数值\n\n\nFLOAT\n4 bytes\n(-3.402 823 466 E+38，-1.175 494 351 E-38)，0，(1.175 494 351 E-38，3.402 823 466 351 E+38)\n0，(1.175 494 351 E-38，3.402 823 466 E+38)\n单精度 浮点数值\n\n\nDOUBLE\n8 bytes\n(-1.797 693 134 862 315 7 E+308，-2.225 073 858 507 201 4 E-308)，0，(2.225 073 858 507 201 4 E-308，1.797 693 134 862 315 7 E+308)\n0，(2.225 073 858 507 201 4 E-308，1.797 693 134 862 315 7 E+308)\n双精度 浮点数值\n\n\nDECIMAL\n对 DECIMAL(M,D)，如果 M&gt;D，为 M+2 否则为 D+2\n依赖于 M 和 D 的值\n依赖于 M 和 D 的值\n小数值\n\n\n时间类型\n\n\n类型\n大小 ( bytes)\n范围\n格式\n用途\n\n\n\nDATE\n3\n1000-01-01&#x2F;9999-12-31\nYYYY-MM-DD\n日期值\n\n\nTIME\n3\n‘-838:59:59’&#x2F;‘838:59:59’\nHH:MM:SS\n时间值或持续时间\n\n\nYEAR\n1\n1901&#x2F;2155\nYYYY\n年份值\n\n\nDATETIME\n8\n1000-01-01 00:00:00&#x2F;9999-12-31 23:59:59\nYYYY-MM-DD HH:MM:SS\n混合日期和时间值\n\n\nTIMESTAMP\n4\n1970-01-01 00:00:00&#x2F;2038 结束时间是第 2147483647 秒，北京时间 2038-1-19 11:14:07，格林尼治时间 2038 年 1 月 19 日 凌晨 03:14:07\nYYYYMMDD HHMMSS\n混合日期和时间值，时间戳\n\n\n字符创类型\n\n\n类型\n大小\n用途\n\n\n\nCHAR\n0-255 bytes\n定长字符串\n\n\nVARCHAR\n0-65535 bytes\n变长字符串\n\n\nTINYBLOB\n0-255 bytes\n不超过 255 个字符的二进制字符串\n\n\nTINYTEXT\n0-255 bytes\n短文本字符串\n\n\nBLOB\n0-65 535 bytes\n二进制形式的长文本数据\n\n\nTEXT\n0-65 535 bytes\n长文本数据\n\n\nMEDIUMBLOB\n0-16 777 215 bytes\n二进制形式的中等长度文本数据\n\n\nMEDIUMTEXT\n0-16 777 215 bytes\n中等长度文本数据\n\n\nLONGBLOB\n0-4 294 967 295 bytes\n二进制形式的极大文本数据\n\n\nLONGTEXT\n0-4 294 967 295 bytes\n极大文本数据\n\n\n表的操作创建表CREATE TABLE table_name (    column_name column_type,    column_name column_type,    column_name column_type,    column_name column_type);\n\n\n表不存在时创建CREATE TABLE IF NOT EXISTS table_name (column_name column_type) \n\n使用 NULL 值默认情况下允许空值，通常可以通过下面的语句显示设置。\nCREATE TABLE IF NOT EXISTS table_name (column_name column_type NULL) \n\n禁用空值CREATE TABLE IF NOT EXISTS table_name (column_name column_type NOT NULL) \n\n主键MySQL 中主键的值必须唯一，所以主键不允许是空值。\nCREATE TABLE IF NOT EXISTS table_name (                                        column_name column_type NOT NULL，                                        PRIMARY KEY (key_1, key_2)                                      );\n\n设置自增每当新添加一行时，设置了 AUTO_INCREMENT 的字段会自动增加，每个表只能有一个自增字段而且必须被索引。\nCREATE TABLE IF NOT EXISTS table_name (column_name column_type NOT NULL AUTO_INCREMENT) \n\n指定默认值默认值只能设置为常数，不支持设置为函数。\nCREATE TABLE IF NOT EXISTS table_name (column_name column_type NOT NULL DEFAULT value)\n\n设置引擎CREATE TABLE table_name (                          column_name column_type,                          column_name column_type,                          column_name column_type,                          column_name column_type                        ) ENGINE=InnoDB;\n\n\n更新表添加新的列ALTER TABLE table_name ADD column_name column_type;\n\n删除列ALTER TABLE table_name DROP column_name;\n\n删除表DROP TABLE table_name;\n\n\n重命名表RENAME TABLE old_name TO new_name;\n\n插入数据\n向表中插入数据\nINSERT INTO table_name VALUES ( value1, value2,...valueN );\n\n向指定列插入数据：\nINSERT INTO table_name ( field1, field2,...fieldN )                       VALUES                       ( value1, value2,...valueN );\n\n插入多行数据：\nINSERT INTO table_name ( field1, field2,...fieldN )                       VALUES                       ( value1, value2,...valueN ),                       ( value1, value2,...valueN ),                       ( value1, value2,...valueN );\n\n使用 INSERT SELECT:\nINSERT INTO table_name_1 ( field1, field2,...fieldN )                       SELECT field1, field2,...fieldN                        FROM table_name_2;\n\n更新数据UPDATE table_naem SET column_name=value WHERE语句\n\n\n\n删除数据DELETE FROM table_name WHERE语句\n\n检索数据检索单列数据SELECT column_name FROM table_name;\n\n\n检索多列数据SELECT column_name_1, column_name_2 FROM table_name;\n\n\n检索所有列SELECT * FROM table_name;\n\n\n检索不同行有的情况下多行的数据可能是相同的，比如下面的 age,第一行和第三行的数据是一样的，第二行和第四行的数据是一样的。\n\n如果希望只显示内容不同的行，可以使用下面的 sql 语句：\nSELECT DISTINCT column_name FROM table_name;\n\n\n如果检索的是多列，每列内容都相同才会视为相同的行。\n\n限制结果行数有时候检索结果数量比较多，如果只希望显示前几行，可以使用如下语句：\nSELECT * FROM table_name LIMIT num;\n\n\n\n上面 sql 语句只能限制搜索结果显示行数，如果希望指定结果显示的起始位置，需要使用下面的语句，比如从第二行开始，显示 3 行数据。\nSELECT * FROM table_name LIMIT num,num;\n\n\n限定表名SELECT table_name.column_name FROM table_name;\n\n数据排序单列排序SELECT * FROM table_name ORDER BY column_name;\n\n\n多列排序SELECT * FROM table_name ORDER BY column_name_1, column_name_2;\n\n\n指定排序方向通过在需要排序的列后添加 DESC 和 ASC 可以指定该列使用降序和升序排列。\n\n过滤数据使用 where 子句SELECT * FROM table_name WHERE column_name=value;\n\n\nwhere 子句支持的操作符\n范围检索SELECT * FROM table_name WHERE column_name BETWEEN value_1 AND value_2;\n\n\n空值检索SELECT * FROM table_name WHERE column_name IS NULL;\n\nAND 操作符需要添加多个过滤条件，可以使用 AND 操作符。\nSELECT * FROM table_name WHERE column_name_1=value_1 AND column_name_2&gt;value_2;\n\n\nOR 操作符与 AND 使用方式相同，表示满足条件之一。\n\n当 ADN 和 OR 同时使用的时候 AND 的优先级比较高，所以必要时刻添加括号改变默认预算顺序。\nIN 操作符SELECT * FROM table_name WHERE column_name IN (value_1, value_2);\n\n\nNOT 操作符NOT 操作符表示否定后面的条件。\nSELECT * FROM table_name WHERE NOT column_name=value;\n\n\nLIKE 操作符LIKE 操作符用来进行通配符过滤。\nSELECT * FROM table_name WHERE column_name LIKE value;\n\n% 通配符表示任意字符重复任意次。\n\n_ 通配符匹配单个字符。\n\n正则表达式SELECT * FROM table_name WHERE column_name REGEXP value;\n\n\nOR| 分割正则表达式，表示 or 的含义，如 1000|2000 表示匹配 1000 或 2000\n[][] 表示匹配字符之一：\n\n[ab]c 表示匹配 ac 或 bc。\n[0-9] 匹配 0~9 之一。\n\n匹配特殊字符如果要匹配 . 符号，需要使用 \\\\.，匹配 \\ 则需要 \\\\\\。\n\n匹配字符类\n匹配多个实例\n定位符\n计算字段拼接字段有时候需要的数据分散在表格的多个字段里，可以使用 CONCAT 函数进行拼接。\nSELECT CONCAT(value_1, value_2) FROM table_name;\n\n\n去除空白RTrim 函数用于去除右侧空白，相应的 LTrim 用于去除左侧空白，TRim 用于去除两侧空白。\n使用别名SELECT column_name AS new_name FROM table_name;\n\n\n算数计算SELECT column_name_1 * column_name_2 AS new_name FROM table_name;\n\n\n数据处理函数文本处理函数\n\n时间和日期处理函数\n数值处理函数\n聚合函数\n\n\n聚合不同值\n数据分组创建分组\n过滤分组过滤分组使用的 HAVING 关键字，使用方法和 WHERE 完全一致，唯一的区别在于前者用于过滤分组，后者用于过滤行。\n\nselect 子句顺序\n\n子查询利用子查询过滤\n作为计算字段使用子查询\n联结表内联结直接从多个表中查询是，MySQL 会简单的做多张表的笛卡尔积，我们需要使用 WHERE 语句过滤创需要的内容。\n\n外联结\n内联结与外联结的区别在于内联结只会保留匹配的内容，而外连接会将主要表内的所有内容保留。\n组合查询UNION 可以用来组合多条查询语句。\n\n约束概念约束是用于规定表中的数据规则，如果存在违反约束的数据行为，行为会被约束终止。Mysql 中的约束有以下几种：\n\n主键约束\n自增约束\n外键约束\n唯一约束\n非空约束\n默认约束\n\n使用主键约束主键不能重复，也不允许为空，并且一个表中只能有一个主键。通常情况下不会使用业务中的数据作为主键，即使它有些时候符合主键的条件（比如身份证号），而是会在业务数据之外新增一列数据专门作为主键。\n创建表时添加主键约束-- 格式&lt;字段名&gt; &lt;数据类型&gt; PRIMARY KEY-- 示例CREATE TABLE 表名 (    id INT PRIMARY KEY,    name VARCHAR(20));\n\n-- 格式[CONSTRAINT &lt;约束名&gt;] PRIMARY KEY [字段名]-- 示例CREATE TABLE 表名 (    id INT,    name VARCHAR(20),    PRIMARY KEY(id, name));\n\n创建表之后添加主键约束-- 格式ALTER TABLE &lt;数据表名&gt; ADD PRIMARY KEY(&lt;字段名&gt;);\n\n删除主键ALTER TABLE &lt;数据表名&gt; DROP PRIMARY KEY;\n\n自增约束在 MySQL 中，当主键定义为自增长后，这个主键的值就不再需要用户输入数据了，而由数据库系统根据定义自动赋值。每增加一条记录，主键会自动以相同的步长进行增长。\n\n默认情况下，AUTO_INCREMENT 的初始值是 1，每新增一条记录，字段值自动加 1；\n一个表中只能有一个字段使用 AUTO_INCREMENT 约束，且该字段必须有索引；\nAUTO_INCREMENT 约束的字段必须具备 NOT NULL 属性；\nAUTO_INCREMENT 约束的字段只能是整数类型（TINYINT、SMALLINT、INT、BIGINT 等）；\nAUTO_INCREMENT 约束字段的最大值受该字段的数据类型约束，如果达到上限，AUTO_INCREMENT 就会失效。\n\n创建表时添加自增-- 格式&lt;字段名&gt; &lt;数据类型&gt; AUTO_INCREMENT-- 示例CREATE TABLE tb_student(    id INT(4) PRIMARY KEY AUTO_INCREMENT,    name VARCHAR(25) NOT NULL);\n\n创建表后添加自增ALTER TABLE &lt;表名称&gt; modify &lt;字段名&gt; &lt;数据类型&gt; auto_increment;\n\n删除自增ALTER TABLE &lt;表名称&gt; modify &lt;字段名&gt; &lt;数据类型&gt;;\n\n设置自增初始值CREATE TABLE tablename (    -- 字段 --) AUTO_INCREMENT=100;\n\n外键约束MySQL 外键约束（FOREIGN KEY）是表的一个特殊字段，经常与主键约束一起使用。对于两个具有关联关系的表而言，相关联字段中主键所在的表就是主表（父表），外键所在的表就是从表（子表）。\n外键用来建立主表与从表的关联关系，为两个表的数据建立连接，约束两个表中数据的一致性和完整性。比如，一个小学只有 1 到 6 年纪，那学生信息中年级也只能是 1 到 6，不能是其它的值。\n主表删除某条记录时，从表中与之对应的记录也必须有相应的改变。一个表可以有一个或多个外键，外键可以为空值，若不为空值，则每一个外键的值必须等于主表中主键的某个值。\n定义外键时，需要遵守下列规则：\n\n主表必须已经存在于数据库中，或者是当前正在创建的表。如果是后一种情况，则主表与从表是同一个表，这样的表称为自参照表，这种结构称为自参照完整性。\n必须为主表定义主键。\n主键不能包含空值，但允许在外键中出现空值。也就是说，只要外键的每个非空值出现在指定的主键中，这个外键的内容就是正确的。\n在主表的表名后面指定列名或列名的组合。这个列或列的组合必须是主表的主键或候选键。\n外键中列的数目必须和主表的主键中列的数目相同。\n外键中列的数据类型必须和主表主键中对应列的数据类型相同。\n\n创建表时设置外键-- 格式[CONSTRAINT &lt;外键名&gt;] FOREIGN KEY 字段名 [，字段名2，…] REFERENCES &lt;主表名&gt; 主键列1 [，主键列2，…]\n\n创建表后添加外键ALTER TABLE &lt;数据表名&gt; ADD CONSTRAINT &lt;外键名&gt;FOREIGN KEY(&lt;列名&gt;) REFERENCES &lt;主表名&gt; (&lt;列名&gt;);\n\n删除外键ALTER TABLE &lt;表名&gt; DROP FOREIGN KEY &lt;外键约束名&gt;;\n\n唯一约束唯一约束（Unique Key）是指所有记录中字段的值不能重复出现。例如，为 id 字段加上唯一性约束后，每条记录的 id 值都是唯一的，不能出现重复的情况。如果其中一条记录的 id 值为‘0001’，那么该表中就不能出现另一条记录的 id 值也为‘0001’。\n唯一约束与主键约束相似的是它们都可以确保列的唯一性。不同的是，唯一约束在一个表中可有多个，并且设置唯一约束的列允许有空值，但是只能有一个空值。而主键约束在一个表中只能有一个，且不允许有空值。比如，在用户信息表中，为了避免表中用户名重名，可以把用户名设置为唯一约束。\n创建表时添加唯一约束&lt;字段名&gt; &lt;数据类型&gt; UNIQUE\n\n创建表后添加唯一约束ALTER TABLE &lt;数据表名&gt; ADD CONSTRAINT &lt;唯一约束名&gt; UNIQUE(&lt;列名&gt;);\n\n删除唯一约束ALTER TABLE &lt;表名&gt; DROP INDEX &lt;唯一约束名&gt;;\n\n默认值默认值（Default）的完整称呼是“默认值约束（Default Constraint）”，用来指定某列的默认值。在表中插入一条新记录时，如果没有为某个字段赋值，系统就会自动为这个字段插入默认值。\n创建表时添加默认值&lt;字段名&gt; &lt;数据类型&gt; DEFAULT &lt;默认值&gt;;\n\n创建表后添加唯一约束ALTER TABLE &lt;数据表名&gt;CHANGE COLUMN &lt;字段名&gt; &lt;数据类型&gt; DEFAULT &lt;默认值&gt;;\n\n删除唯一约束ALTER TABLE &lt;数据表名&gt;CHANGE COLUMN &lt;字段名&gt; &lt;字段名&gt; &lt;数据类型&gt; DEFAULT NULL;\n\n非空约束非空约束（NOT NULL）指字段的值不能为空。对于使用了非空约束的字段，如果用户在添加数据时没有指定值，数据库系统就会报错。可以通过 CREATE TABLE 或 ALTER TABLE 语句实现。在表中某个列的定义后加上关键字 NOT NULL 作为限定词，来约束该列的取值不能为空。\n创建表时添加非空约束&lt;字段名&gt; &lt;数据类型&gt; NOT NULL;\n\n创建表后添加非空约束ALTER TABLE &lt;数据表名&gt;CHANGE COLUMN &lt;字段名&gt;&lt;字段名&gt; &lt;数据类型&gt; NOT NULL;\n\n删除唯一约束ALTER TABLE &lt;数据表名&gt;CHANGE COLUMN &lt;字段名&gt; &lt;字段名&gt; &lt;数据类型&gt; NULL;\n\n检查约束检查约束（CHECK）是用来检查数据表中字段值有效性的一种手段，可以通过 CREATE TABLE 或 ALTER TABLE 语句实现。设置检查约束时要根据实际情况进行设置，这样能够减少无效数据的输入。\n创建表时添加非空约束CHECK(&lt;检查约束&gt;)\n\n创建表后添加非空约束ALTER TABLE tb_emp7 ADD CONSTRAINT &lt;检查约束名&gt; CHECK(&lt;检查约束&gt;)\n\n删除唯一约束ALTER TABLE &lt;数据表名&gt; DROP CONSTRAINT &lt;检查约束名&gt;;\n\n事务\n开启事务\nSTART TRANSACTION;\n\n\n\n回滚\nROLLBACK;\n\n提交\nCOMMIT;\n\n设置占位点\n  SAVEPOINT name;\n\n\n回滚到占位点\nROLLBACK TO name;\n\n\n更改默认提交行为\nSET autocommit=0;\n\n全球化查看支持的字符集SHOW CHARACTER SET;\n\n\n支持校对的列表SHOW COLLATION;\n\n\n查看当前字符集合校对\n\n设置表的默认字符集和校对CREATE TABLE table_name (column_name column_type,                         column_name column_type,                         column_name column_type,                         column_name column_type)                         DEFUALT CHARATER SET utf8                         COLLATION utf8mb4_0900_ai_ci\n\n指定列的字符集和校对CREATE TABLE table_name (column_name column_type                         DEFUALT CHARATER SET utf8                         COLLATION utf8mb4_0900_ai_ci,                         column_name column_type)  \n\n查找时设置字符集SELECT * FROM table_name ORDER BY column_name COLLATE utf8mb4_0900_ai_ci;\n\n安全管理查看所有用户USER mysql;SELECT user FROM user;\n\n\n创建新用户CREATE USER user_name IDENTIFIED BY &#x27;password&#x27;;\n\n重命名账户RENAME old TO new;\n\n删除账户DROP USER name;\n\n查看用户权限SHOW GRANTS FOR name;\n\n\n设置访问权限GRANT SELECT ON test.* TO name;\n\n\n\n\n撤销访问权限REVOKE SELECT ON test.* FROM name;\n\n修改密码\n设置其它用户密码\nSET PASSWORD FOR username = Password(&quot;password&quot;);\n\n设置自己密码\nSET PASSWORD = Password(&quot;password&quot;);\n\n"},{"title":"socket连接不安全的原因.md","url":"/2022/12/19/socket%E8%BF%9E%E6%8E%A5%E4%B8%8D%E5%AE%89%E5%85%A8%E7%9A%84%E5%8E%9F%E5%9B%A0/","content":"多个线程操作 socket 的时候是可能出现线程安全问题，如下面图示中的展示的那样，当线程 1 通过 socket 连接向服务器发送信息，这时候线程 2 恰好通过 socket 连接在读取服务端的数据，那么本该由线程 1 接收并处理的信息就被线程 2 读取到了。\n\n下面使用代码模拟这个过程：​\n//服务端代码try ( ServerSocket serverSocket = new ServerSocket(1996))&#123;    // 监听连接请求    Socket socket = serverSocket.accept();    // 获取请求信息    InputStream inputStream = socket.getInputStream();    byte[] bytes = new byte[10234];    int len = inputStream.read(bytes);    // 打印请求信息    System.out.println(&quot;收到信息：&quot; + new String(bytes, 0, len));    // 写回响应信息    OutputStream outputStream = socket.getOutputStream();    outputStream.write(&quot;服务端返回信息&quot;.getBytes());    Thread.sleep(10000000);&#125; catch (IOException | InterruptedException e) &#123;    throw new RuntimeException(e);&#125;\n\n//客户端代码Socket socket = new Socket(&quot;127.0.0.1&quot;, 1996);// 模拟线程1new Thread(()-&gt;&#123;    try &#123;        //线程1发送信息        socket.getOutputStream().write(&quot;线程1发送的信息&quot;.getBytes());        // 线程1进行其他操作        Thread.sleep(5000);        byte[] bytes = new byte[10234];        int len = socket.getInputStream().read(bytes);        System.out.println(&quot;线程1收到的信息：&quot;+new String(bytes, 0 , len));    &#125; catch (IOException | InterruptedException e) &#123;        throw new RuntimeException(e);    &#125;&#125;).start();// 模拟线程2Thread.sleep(1000);byte[] bytes = new byte[10234];int len = socket.getInputStream().read(bytes);System.out.println(&quot;线程2收到的信息：&quot;+new String(bytes, 0 , len));\n\n服务端的运行结果为：​\n\n客户端运行结果为：​\n\n从运行结果中也可以看到，本该由线程 1 接收的信息被线程 2 收到了。​\n","tags":["计算机网络"]},{"title":"Spring基于XML的配置.md","url":"/2023/03/11/Spring%E5%9F%BA%E4%BA%8EXML%E7%9A%84%E9%85%8D%E7%BD%AE/","content":"创建容器ClassPathXmlApplicationContext 是 ApplicationContext 类的一个实现，用来加载 xml 配置文件生成容器。\nClassPathXmlApplicationContext applicationContext = new ClassPathXmlApplicationContext(&quot;classpath:/bean.xml&quot;);Object student = applicationContext.getBean(&quot;student&quot;);System.out.println(student.getClass());\n\nBean 定义配置文件的一般形式如下，其中每一个 bean 标签都表示一个对象的定义，Spring 创建容器的过程中，会读取配置文件中的定义的 bean，之后可以根据 bean 中的各种信息创建对象实例。\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans        http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;         &lt;bean id=&quot;hello&quot; class=&quot;com.chang.Car&quot;&gt;        &lt;property name=&quot;name&quot; value=&quot;Spring&quot;/&gt;    &lt;/bean&gt;&lt;/beans&gt;\n\nid 属性每一个 bean 都有一个 id 属性，它是 bean 的唯一标识，可以通过 id 属性从容器中获得 bean，在同一个容器中所用的 id 属性应该是不同的。下面的例子展示了如和通过 id 获取对应的 bean。\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans        http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;         &lt;bean id=&quot;student&quot; class=&quot;com.chang.bean.Student&quot;&gt;        &lt;property name=&quot;name&quot; value=&quot;chang&quot;/&gt;    &lt;/bean&gt;&lt;/beans&gt;\n\nObject student = applicationContext.getBean(&quot;student&quot;);\n\n如果在 bean 的定义中没有指定 id 的化，Spring 会分配一个默认的 id 属性给该 bean，例如下面定义的 bean，Spring 给他的默认 id 可能为 com.liang.bean.Student#0。\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans        http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;         &lt;bean class=&quot;com.chang.bean.Student&quot;&gt;        &lt;property name=&quot;name&quot; value=&quot;chang&quot;/&gt;    &lt;/bean&gt;&lt;/beans&gt;\n\nclass 属性bean 标签中的 class 属性值为一个全类名，它表示该 bean 的类型，从容器中获取 bean 的时候，也可以根据类型来获取。\nObject student = applicationContext.getBean(Student.class);\n\nname 属性name 属性可以用来个 bean 起一个或多个别名，起多个别名的时候要用逗号、分号或空格隔开，如下所示：\n&lt;bean name=&quot;studentBean bean&quot; class=&quot;com.liang.bean.StudentBean&quot;/&gt;\n\nalias 属性alias 标签也可以用来给 bean 起别名，其中 alias 属性是别名，name 属性是对应该别名的 bean 的 id。\n&lt;alias name=&quot;fromName&quot; alias=&quot;toName&quot;/&gt;\n\n工厂方法创建 Bean前文中展示了 bean 最通常的配置方法，使用那样的配置时，创建 bean 时候是调用了对应类的构造方法。\n在有些代码中，为了实现程序的低耦合，创建实例的时候通常不会直接调用类的构造函数，而是使用一些工厂方法，针对这种情况，Spring 也提供了支持。\n静态工厂方法使用静态工厂方法创建 bean 实例时，class 属性也必须指定，但此时 class 属性并不是指定 bean 的类型，而是该 bean 对应的静态工厂类，因为 Spring 需要知道是用哪个工厂来创建 Bean 实例。另外，还需要使用 factory-method 属性来指定静态工厂方法名，Spring 将调用静态工厂方法，来返回一个 bean。一旦获得了指定 bean 实例，Spring 后面的处理步骤与采用普通方法创建 bean 实例则完全一样。需要注意的是，当使用静态工厂方法来创建 bean 时，这个 factory-method 必须要是静态的。\npublic class Car &#123;    private String name;    private int age;      public void setAge( int age) &#123;        this.age = age;    &#125;      public void setName(String name_) &#123;        this.name = name;    &#125;  &#125;\n\npublic class StaticFactory &#123;     public static Car getCar(String name) &#123;        Car car = new Car();        car.setName(name);        return car;   &#125; &#125;\n\n这里 constructor-arg 标签用于指定工厂方法需要的参数，property 标签用于注入属性，此处简单知道作用即刻，后面会对这两个标签详细展开。\n&lt;bean id=&quot;car&quot; class=&quot;com.liang.StaticFactory&quot; factory-method=&quot;getCar&quot;&gt;     &lt;constructor-arg value=&quot;Maserati&quot;/&gt;     &lt;property name=&quot;age&quot; value=&quot;12&quot;/&gt;&lt;/bean&gt;\n\n实例工厂方法既然有了静态工厂方法，那么必然会有实例工厂方法，两者的区别仅在于前者方法属于类，后者方法属于对象实例。\npublic class Car &#123;    private String name;    private int age;      public void setAge( int age) &#123;        this.age = age;    &#125;      public void setName(String name_) &#123;        this.name = name;    &#125;  &#125;\n\npublic class CarFactory &#123;     public Car getCar(String name) &#123;        Car car = new Car();        car.setName(name);        return car;   &#125; &#125;\n\n既然是实例工厂方法，那么首先需要创建出对应的实例，也就是下面第一行中的定义。之后再正真定义 &#96;b\n&lt;bean id=&quot;carfactory&quot; class=&quot;com.liang.CarFactory&quot;&gt;&lt;/bean&gt;&lt;bean factory-bean=&quot;carfactory&quot; factory-method=&quot;getCar&quot;&gt;    &lt;constructor-arg value=&quot;Maserati&quot;/&gt;    &lt;property name=&quot;age&quot; value=&quot;12&quot;/&gt;&lt;/bean&gt;\n\nFactoryBeanSpring 中有两种类型的 bean，一种是普通的 bean，另一种是工厂 bean，即 FactoryBean。工厂 bean 跟普通 bean 不同，其返回的对象不是指定类的一个实例，而是该工厂 bean 的 getObject 方法返回的对象。\npublic interface FactortBean &#123;    //返回实例    Object getObject() throws Exception;    //返回类型    class getObjectType();    //返回的实例是否为单例    boolean isSingleton();&#125;\n\n上面是 FactoryBean 接口，下面我们看一下它的具体使用。\npublic class Car &#123;    private String name;    private int age;    public void setAge( int age) &#123;        this.age = age;    &#125;      public void setName(String name_) &#123;        this.name = name;    &#125;  &#125;\n\npublic class CarFactoryBean implements FactoryBean&#123;    private String name;    private int age;      public void setAge( int age) &#123;        this.age = age;    &#125;      public void setName(String name_) &#123;        this.name = name;    &#125;      public Object getObject() throws Exception &#123;        Car car = new Car();        car.setName(this.name);        car.setAge(this.age);        return car;    &#125;       public Class&lt;?&gt; getObjectType() &#123;  //注意这个方法主要作用是：该方法返回的类型是在ioc容器中getbean所匹配的类型        return Car.class;    &#125;      public boolean isSingleton() &#123;        return true;    &#125;&#125;\n\n我们在定义中没有添加 Car，而是直接在容器中添加了一个 CarFactoryBean，不过如果从容器中获取 id 为 car 的 bean 时，获得并不是 CarFactoryBean 的实例，而是 Car 的实例。这是应为 Spring 首先创建了一个 CarFactoryBean 的实例，然后调用了 getObject 方法获取返回值，并将该返回值作为 id 对应的实例。\n&lt;bean id=&quot;car&quot; class=&quot;com.liang.CarFactoryBean&quot;&gt;     &lt;property name=&quot;name&quot; value=&quot;chang&quot;/&gt;     &lt;property name=&quot;age&quot; value=&quot;12&quot;/&gt;&lt;/bean&gt;\n\n导入其他配置在一个项目中，Spring 可能会管理分属不同业务的 bean，如果将所有的 bean 定义在同一个配置文件中，会显得比较混乱。那么可以将不同业务的 bean 定义在不同的配置文件中，然后再将其汇总。通过下面的方式，可以导入其他的配置到当前配置中。\n&lt;beans&gt;    &lt;import resource=&quot;services.xml&quot;/&gt;    &lt;import resource=&quot;resources/messageSource.xml&quot;/&gt;    &lt;import resource=&quot;/resources/themeSource.xml&quot;/&gt;    &lt;bean id=&quot;bean1&quot; class=&quot;...&quot;/&gt;    &lt;bean id=&quot;bean2&quot; class=&quot;...&quot;/&gt;&lt;/beans&gt;\n\n所有路径都相对于当前配置文件，因此 services.xml 必须与进行导入的文件位于同一目录或位置，而 messageSource.xml 和 themeSource.xml 必须位于导入文件位置下方的 resources 位置开头的斜杠会被忽略，所以通常建议省去斜杠。\n除了使用相对路径，还可以使用 classpath:/com/liang/bean.xml 以及 file:C:/config/services.xml 这样的绝对路径。\n不同配置文件中的 bean 如果有相同的 id，即使是不相同的类，先定义的会把后定义的类覆盖掉。\n除了使用这种方法汇总不同的配置文件，在创建容器的时候也支持添加多个文件，如下面的代码所示。\nClassPathXmlApplicationContext applicationContext = new ClassPathXmlApplicationContext(&quot;classpath:/bean.xml&quot;, &quot;classpath:/bean2.xml&quot;);\n\n依赖注入所谓的依赖注入，简单的理解就是给实例中的属性赋值，比如下面的类，在创建了对象之后，通常要对 age 和 name 两个属性赋值。\npublic class Car &#123;    private String name;    private int age;    public Car() &#123;     &#125;    public Car(String name, int age) &#123;        this.name = name;        this.age = age;    &#125;      public void setAge( int age) &#123;        this.age = age;    &#125;      public void setName(String name_) &#123;        this.name = name;    &#125;  &#125;\n\n在 Sping 中有两种依赖注入的方式，一种是通过构造函数，一种是通过 setter 方法，也就是对应了我们编程时给对象属性赋值的两种方法。\nCar carOne = new Car(&quot;chang&quot;, 12);Car carTwo = new Car();carTwo.setName(&quot;liang&quot;);carTwo.setAge(13);\n\n调用的带参数的构造方法创建对象实例后，任然可以使用 set 方法更新属性值，所以在 Spring 中 setter 方法可用于覆盖构造函数中配置的依赖，构造函数一般用于强制性依赖，setter 方法用于可选依赖。\n基于构造函数注入public class TeacherBean &#123;    private String name;        private StudentBean student;    public TeacherBean(String name, StudentBean student) &#123;        this.name = name;        this.student = student;    &#125;&#125;\n\n当类的属性是通过构造函数赋值的时候，在定义 bean 的时候就需要基于构造函数将属性注入，通常配置如下：\n&lt;beans&gt;    &lt;bean id=&quot;teacher&quot; class=&quot;con.liang.TeacherBean&quot;&gt;        &lt;constructor-arg value=&quot;chang&quot;/&gt;        &lt;constructor-arg ref=&quot;student&quot;/&gt;    &lt;/bean&gt;    &lt;bean id=&quot;student&quot; class=&quot;com.liang.StudentBean&quot;/&gt;&lt;/beans&gt;\n\n其中 &lt;constructor-arg value=&quot;chang&quot;/&gt; 指定一个基本类型的参数，&lt;constructor-arg ref=&quot;student&quot;/&gt; 指定一个对象。\n上面的示例中两个参数比较容易区分，如果两个参数都是基本类型或属于同一个类，则需要额外属性进行辅助，看下面的例子：\npublic class TeacherBean &#123;    private String name;    private int age;    public TeacherBean(String name, int age) &#123;        this.name = name;        this.age = age;    &#125;&#125;\n\n\n可以通过 type 指定类型进行区分。\n这个时候如果还是只用不带任何属性的 canstructor-arg 标签的话，Spring 是无法分清楚 1 这个值时赋给 name 还是 age 的，因为无法区分 1 这个字面值到底是数字还是字符串。\n&lt;bean id=&quot;teacher&quot;  class=&quot;com.liang.bean.TeacherBean&quot;&gt;    &lt;constructor-arg value=&quot;1&quot;/&gt;    &lt;constructor-arg value=&quot;2&quot;/&gt;&lt;/bean&gt;\n\n使用 type 属性就可以解决这个问题，下面的配置中就明确指明了 1 要赋给一个字符串类型，但这种方法也有缺点，如果多个参数类型相同的话，就无法使用了。\n&lt;bean id=&quot;teacher&quot;  class=&quot;com.liang.bean.TeacherBean&quot;&gt;    &lt;constructor-arg type=&quot;java.lang.String&quot; value=&quot;1&quot;/&gt;    &lt;constructor-arg type=&quot;int&quot; value=&quot;2&quot;/&gt;&lt;/bean&gt;\n\n可以指定索引进行区分。\n这个方法比较好理解，直接使用参数在参数列表中的序号定位即可，比如下面的配置，将 1 赋给 0 号位的参数。\n&lt;bean id=&quot;teacher&quot;  class=&quot;com.liang.bean.TeacherBean&quot;&gt;    &lt;constructor-arg index=&quot;0&quot; value=&quot;1&quot;/&gt;    &lt;constructor-arg index=&quot;1&quot; value=&quot;2&quot;/&gt;&lt;/bean&gt;\n\n可以指定属性名进行区分。\n这个也是比较清晰，使用参数名来对应值。\n&lt;bean id=&quot;teacher&quot;  class=&quot;com.liang.bean.TeacherBean&quot;&gt;    &lt;constructor-arg name=&quot;name&quot; value=&quot;1&quot;/&gt;    &lt;constructor-arg name=&quot;age&quot; value=&quot;2&quot;/&gt;&lt;/bean&gt;\n\n基于 Setter 注入在不通过构造方法注入时，Spring 需要首先调用类中无参数的构造函数进行实例化，之后再通过 setter 方法注入属性，所以必须保证无参数的构造函数以及 setter 方法存在。\npublic class TeacherBean &#123;    private String name;    private int age;   &#125;\n\n对于上面的这个类，如果需要实现属性注入，配置如下：\n&lt;bean id=&quot;teacher&quot;  class=&quot;com.liang.bean.TeacherBean&quot;&gt;    &lt;property name=&quot;name&quot; value=&quot;12&quot; /&gt;    &lt;property name=&quot;age&quot; value=&quot;122&quot; /&gt;&lt;/bean&gt;\n\n如果注入的属性时一个对象时，可以使用 ​ &lt;property name=&quot;student&quot; ref=&quot;student&quot; /&gt; 这样的方式：\n&lt;beans&gt;    &lt;bean id=&quot;teacher&quot; class=&quot;con.liang.TeacherBean&quot;&gt;        &lt;property name=&quot;name&quot; value=&quot;12&quot; /&gt;        &lt;property name=&quot;student&quot; ref=&quot;student&quot; /&gt;    &lt;/bean&gt;    &lt;bean id=&quot;student&quot; class=&quot;com.liang.StudentBean&quot;/&gt;&lt;/beans&gt;\n\n注入配置细节常量注入\n字面值: 可用字符串表示的值，可以通过 value 属性或标签进行注入。\n&lt;bean id=&quot;teacher&quot;  class=&quot;com.liang.bean.TeacherBean&quot;&gt;       &lt;property name=&quot;name&quot; value=&quot;12&quot; /&gt;       &lt;property name=&quot;age&quot;&gt;               &lt;value&gt;12&lt;/value&gt;       &lt;/property &gt;&lt;/bean&gt;\n\n支持将 value 标签中的字符串转化为 java.util.Properties 类\n&lt;!-- typed as a java.util.Properties --&gt;&lt;property name=&quot;properties&quot;&gt;    &lt;value&gt;        jdbc.driver.className=com.mysql.jdbc.Driver        jdbc.url=jdbc:mysql://localhost:3306/mydb    &lt;/value&gt;&lt;/property&gt;\n\n基本数据类型及其封装类、String 等类型都可以采取字面值注入的方式\n\n若字面值中包含特殊字符，可以使用  把字面值包裹起来。\n\n\nBean 注入\n可以用 ref 属性或标签引入外部类\n&lt;bean id=&quot;addr&quot; class=&quot;com.chang.pojo.Address&quot;&gt;    &lt;property name=&quot;address&quot; value=&quot;重庆&quot;/&gt;&lt;/bean&gt;&lt;!-- 使用ref属性 --&gt;&lt;bean id=&quot;student&quot; class=&quot;com.chang.pojo.Student&quot;&gt;    &lt;property name=&quot;name&quot; value=&quot;小明&quot;/&gt;    &lt;property name=&quot;address&quot; ref=&quot;addr&quot;/&gt;&lt;/bean&gt;&lt;!-- 使用标签 --&gt;&lt;bean id=&quot;student&quot; class=&quot;com.chang.pojo.Student&quot;&gt;    &lt;property name=&quot;name&quot; value=&quot;小明&quot;/&gt;    &lt;property name=&quot;address&quot;&gt;        &lt;ref bean=&quot;addr&quot;/&gt;    &lt;/property&gt;&lt;/bean&gt;\n\n用 ref 标签的 parent 属性可以从父容器中获的 bean\n&lt;!-- in the parent context --&gt;&lt;bean id=&quot;accountService&quot; class=&quot;com.something.SimpleAccountService&quot;&gt;    &lt;!-- insert dependencies as required as here --&gt;&lt;/bean&gt;\n\n&lt;!-- in the child (descendant) context --&gt;&lt;bean id=&quot;accountService&quot; &lt;!-- bean name is the same as the parent bean --&gt;    class=&quot;org.springframework.aop.framework.ProxyFactoryBean&quot;&gt;    &lt;property name=&quot;target&quot;&gt;        &lt;ref parent=&quot;accountService&quot;/&gt; &lt;!-- notice how we refer to the parent bean --&gt;    &lt;/property&gt;    &lt;!-- insert other configuration and dependencies as required here --&gt;&lt;/bean&gt;\n\n可以使用 idref 代替 ref 标签\n使用 idref 标签在容器部署的时候会验证 bean 是否存在。\n&lt;bean id=&quot;theTargetBean&quot; class=&quot;...&quot;/&gt;&lt;bean id=&quot;theClientBean&quot; class=&quot;...&quot;&gt;    &lt;property name=&quot;targetName&quot;&gt;        &lt;idref bean=&quot;theTargetBean&quot;/&gt;    &lt;/property&gt;&lt;/bean&gt;\n\n可以使用内部类\n&lt;bean id=&quot;student&quot; class=&quot;com.chang.pojo.Student&quot;&gt;    &lt;property name=&quot;name&quot; value=&quot;小明&quot;/&gt;    &lt;property name=&quot;address&quot;&gt;        &lt;bean id=&quot;addr&quot; class=&quot;com.chang.pojo.Address&quot;&gt;            &lt;property name=&quot;address&quot; value=&quot;重庆&quot;/&gt;    &lt;/bean&gt;    &lt;/property&gt;&lt;/bean&gt;\n\n内部类不用指明 id 和 name 属性，但不能用于其他地方。\n\nSpring 支持使用级联属性赋值。\n&lt;bean id=&quot;addr&quot; class=&quot;com.chang.pojo.Address&quot;&gt;    &lt;property name=&quot;address&quot; value=&quot;重庆&quot;/&gt;&lt;/bean&gt;&lt;bean id=&quot;student&quot; class=&quot;com.chang.pojo.Student&quot;&gt;    &lt;property name=&quot;name&quot; value=&quot;小明&quot;/&gt;    &lt;property name=&quot;address&quot; ref=&quot;addr&quot;/&gt;    &lt;property name=&quot;adderss.address&quot; value=&quot;重庆&quot;/&gt;&lt;/bean&gt;\n\n数组注入&lt;bean id=&quot;student&quot; class=&quot;com.kuang.pojo.Student&quot;&gt;    &lt;property name=&quot;name&quot; value=&quot;小明&quot;/&gt;    &lt;property name=&quot;address&quot; ref=&quot;addr&quot;/&gt;    &lt;property name=&quot;books&quot;&gt;        &lt;array&gt;            &lt;value&gt;西游记&lt;/value&gt;            &lt;value&gt;红楼梦&lt;/value&gt;            &lt;value&gt;水浒传&lt;/value&gt;        &lt;/array&gt;    &lt;/property&gt;&lt;/bean&gt;\n\nList 注入&lt;property name=&quot;someList&quot;&gt;    &lt;list&gt;        &lt;value&gt;a list element followed by a reference&lt;/value&gt;        &lt;ref bean=&quot;myDataSource&quot; /&gt;    &lt;/list&gt;&lt;/property&gt;\n\nMap 注入&lt;property name=&quot;someMap&quot;&gt;    &lt;map&gt;        &lt;entry key=&quot;an entry&quot; value=&quot;just some string&quot;/&gt;        &lt;entry key =&quot;a ref&quot; value-ref=&quot;myDataSource&quot;/&gt;    &lt;/map&gt;&lt;/property&gt;\n\nset 注入&lt;property name=&quot;someSet&quot;&gt;    &lt;set&gt;        &lt;value&gt;just some string&lt;/value&gt;        &lt;ref bean=&quot;myDataSource&quot; /&gt;    &lt;/set&gt;&lt;/property&gt;\n\nProperties 注入&lt;property name=&quot;info&quot;&gt;    &lt;props&gt;        &lt;prop key=&quot;学号&quot;&gt;20190604&lt;/prop&gt;        &lt;prop key=&quot;性别&quot;&gt;男&lt;/prop&gt;        &lt;prop key=&quot;姓名&quot;&gt;小明&lt;/prop&gt;    &lt;/props&gt;&lt;/property&gt;\n\n集合合并bean 标签中有一个属性为 abstract，默认情况下该值为 false，如果将他设置为 true 的话，那么容器将不会创建它的实例。它需要和 parent 配合使用，姑且可以将 abstrcat 属性的 bean 称为父 bean，将带有 parent 属性的 bean 称为子 bean，父 bean 中的 property 标签会被继承到子 bean 中，比如下面的例子中，&lt;property name=&quot;name&quot; value = &quot;chang&quot;/&gt; 会被自动添加到子 bean 中。\n&lt;beans&gt;    &lt;bean id=&quot;parent&quot; abstract=&quot;true&quot; class=&quot;example.ComplexObject&quot;&gt;        &lt;property name=&quot;name&quot; value = &quot;chang&quot;/&gt;        &lt;property name=&quot;adminEmails&quot;&gt;            &lt;props&gt;                &lt;prop key=&quot;administrator&quot;&gt;[emailprotected]&lt;/prop&gt;                &lt;prop key=&quot;support&quot;&gt;[emailprotected]&lt;/prop&gt;            &lt;/props&gt;        &lt;/property&gt;    &lt;/bean&gt;    &lt;bean id=&quot;child&quot; parent=&quot;parent&quot;&gt;        &lt;property name=&quot;adminEmails&quot;&gt;            &lt;!-- the merge is specified on the child collection definition --&gt;            &lt;props merge=&quot;true&quot;&gt;                &lt;prop key=&quot;sales&quot;&gt;[emailprotected]&lt;/prop&gt;                &lt;prop key=&quot;support&quot;&gt;[emailprotected]&lt;/prop&gt;            &lt;/props&gt;        &lt;/property&gt;    &lt;/bean&gt;&lt;beans&gt;\n\n子 bean 如果和父 bean 定义了相同的属性，那么后者会把前者的值覆盖。不过如果属性是集合的话，可以开启集合的合并行为，目前合并行为适用于 &lt;list/&gt;，&lt;map/&gt;、&lt;set/&gt; 和 &lt;properties&gt; 集合类型，需要做的是将 merge 属性设置为 true。\n在合并 List 元素时父 bean 的值位于所有子级列表的值之前，对于 Map，Set 和 Properties 集合类型，会继承所有父级中的元素，对于 key 相同的元素会进行覆盖。\n空字符串和 null 值注入&lt;!-- 等价于 wife = null --&gt;&lt;property name=&quot;wife&quot;&gt;&lt;null/&gt;&lt;/property&gt;&lt;!-- 等价于 email = &quot;&quot; --&gt;&lt;property name=&quot;email&quot; value=&quot;&quot;/&gt;\n\n注入拓展: P 命名空间在 beans 中添加 xmlns:p=&quot;http://www.springframework.org/schema/p&quot; 可以开启 P 命名空间，作用是可以使用类似 p:email 的属性替代 property 标签。\n&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;    xmlns:p=&quot;http://www.springframework.org/schema/p&quot;    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans        http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;    &lt;bean name=&quot;classic&quot; class=&quot;com.example.ExampleBean&quot;&gt;        &lt;property name=&quot;email&quot; value=&quot;[emailprotected]&quot;/&gt;    &lt;/bean&gt;    &lt;bean name=&quot;p-namespace&quot; class=&quot;com.example.ExampleBean&quot;        p:email=&quot;[emailprotected]&quot;/&gt;&lt;/beans&gt;\n\n注入拓展: c 命名空间在 beans 中添加 xmlns:c=&quot;http://www.springframework.org/schema/c&quot; 可以开启 C 命名空间，作用是使用类似 c:thingTwo-ref 的属性替代 constructor-arg 标签。\n&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;    xmlns:c=&quot;http://www.springframework.org/schema/c&quot;    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans        http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;    &lt;bean id=&quot;thingOne&quot; class=&quot;x.y.ThingTwo&quot;/&gt;    &lt;bean id=&quot;thingTwo&quot; class=&quot;x.y.ThingThree&quot;/&gt;    &lt;!-- traditional declaration --&gt;    &lt;bean id=&quot;thingOne&quot; class=&quot;x.y.ThingOne&quot;&gt;        &lt;constructor-arg ref=&quot;thingTwo&quot;/&gt;        &lt;constructor-arg ref=&quot;thingThree&quot;/&gt;        &lt;constructor-arg value=&quot;[emailprotected]&quot;/&gt;    &lt;/bean&gt;    &lt;!-- c-namespace declaration --&gt;    &lt;bean id=&quot;thingOne&quot; class=&quot;x.y.ThingOne&quot; c:thingTwo-ref=&quot;thingTwo&quot; c:thingThree-ref=&quot;thingThree&quot; c:email=&quot;[emailprotected]&quot;/&gt;&lt;/beans&gt;\n\nutil 里的集合标签使用基本的集合标签定义集合时 , 不能将集合作为独立的 bean 定义 , 导致其他 bean 无法引用该集合 , 无法让集合在不同 bean 之间共享。在 beans 中添加 xmlns:util=&quot;http://www.springframework.org/schema/util&quot; 可以开启集合标签，它实现了集合类型的独立定义。\n&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;    xmlns:util=&quot;http://www.springframework.org/schema/util&quot;    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans        http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;    &lt;util:list id=&quot;list&quot;&gt;        &lt;ref bean=&quot;car1&quot;/&gt;        &lt;ref bean=&quot;car2&quot;/&gt;        &lt;ref bean=&quot;car3&quot;/&gt;         &lt;ref bean=&quot;car4&quot;/&gt;    &lt;/util:list&gt;    &lt;bean id=&quot;car1&quot; class=&quot;com.chang.Car&quot;&gt;&lt;/bean&gt;    &lt;bean id=&quot;car2&quot; class=&quot;com.chang.Car&quot;&gt;&lt;/bean&gt;    &lt;bean id=&quot;car3&quot; class=&quot;com.chang.Car&quot;&gt;&lt;/bean&gt;    &lt;bean id=&quot;car4&quot; class=&quot;com.chang.Car&quot;&gt;&lt;/bean&gt;      &lt;bean id=&quot;person&quot; class=&quot;com.chang.Person&quot;&gt;        &lt;property name=&quot;car&quot; ref=&quot;list&quot;/&gt;    &lt;/bean&gt;&lt;/beans&gt;\n\n自动装配Spring 容器可以自动装配 bean，需要使用 autowire 属性里指定自动装配的模式。这个自动装配可以简单的理解为，如果一个 bean 的某个属性类型为 A，当容器中存在一个类型为 A 的 bean 时，Spirng 可以自动将 A 类型的 bean 赋给该属性。\npublic class User &#123;    private Car car;&#125;public class Car &#123;&#125;\n\n在下面的配置中，id 为 car 的 bean 会自动被赋给 user 的 car 属性。\n&lt;bean id=&quot;user&quot; class=&quot;com.liang.User&quot; autowire=&quot;byName&quot;&gt;&lt;/bean&gt;&lt;bean id=&quot;car&quot; class=&quot;com.liang.Car&quot;&gt;&lt;/bean&gt;\n\nautowire 的可选值有多个，分别代表不同的装配模式：\n\nno：默认值，表示不进行自动装配，所有的 bean 引用必须由手动定义。对于大型部署，建议不要更改默认设置，因为明确指定协作者可以提供更好的控制和清晰度，在某种程度上，它记录了系统的结构。\nbyName：按属性名称自动装配，Spring 会寻找与属性同名的 bean。例如，如果一个 bean 包含一个 master 属性，那么 Spring 将查找一个名为 master 的 bean 来为它赋值。\nbyType：与 byName 类似，只不过它查找 bean 的依据是属性的类型。\nconstructor：类似于 byType，但它适用于构造函数的情况。\n\n在 byType 或 constructor 自动装配模式下，可以自动按类型装配数组或集合。如果使用的是 map 并且 key 是 String 类型，则使用 bean 的 id 属性作为 key。\npublic class TeacherBean &#123;   private StudentBean[] students;    public void setStudents(StudentBean[] students) &#123;        this.students = students;    &#125;&#125;public class StudentBean &#123;&#125;\n\n&lt;bean id=&quot;teacher&quot;  class=&quot;com.liang.bean.TeacherBean&quot; autowire=&quot;byType&quot; /&gt;&lt;bean class=&quot;com.liang.bean.StudentBean&quot;/&gt;&lt;bean class=&quot;com.liang.bean.StudentBean&quot;/&gt;\n\nbean 中还有一个属性 autowire-candidate，将它设置为 false 后，该 bean 不参与按类型自动装配，但是不影响按名字装配。\n&lt;bean class=&quot;com.liang.bean.StudentBean&quot; autowire-candidate=&quot;false&quot;/&gt;\n\n继承和依赖继承Spring 允许继承 bean 的配置，被继承的 bean 称为父 ​ bean，继承这个父 Bean 的 Bean ​ 称为子 Bean，前面在集合合并中简单的提过，这里详细讲解一下。子 bean ​ 从父 bean ​ 中继承配置，包括 bean 的属性配置，子 bean 也可以覆盖从父 bean 继承过来的配置。父 bean 可以作为配置模板，也可以作为 bean 实例。若只想把父 bean 作为模板, 可以设置 bean 的 abstract ​ 属性为 ​ true，这样 Spring 将不会实例化这个 bean，并不是 bean 元素里的所有属性都会被继承，比如: autowire, abstract 等。\n&lt;bean id=&quot;parent&quot; abstract=&quot;true&quot;&gt;    &lt;property name=&quot;parentName&quot;&gt;        &lt;value&gt;&lt;/value&gt;    &lt;/property&gt;&lt;/bean&gt;&lt;bean id=&quot;child&quot; class=&quot;com.spring.auto.autowire.Parent&quot; parent=&quot;parent&quot;&gt;    &lt;property name=&quot;parentName&quot;&gt;        &lt;value&gt;抽象类实现&lt;/value&gt;    &lt;/property&gt;&lt;/bean&gt;\n\n依赖Spring 允许用户通过 depends-on 属性设定 bean 前置依赖的 bean，前置依赖的 bean 会在本 bean 实例化之前创建好。如果前置依赖于多个 bean，则可以通过逗号，空格隔开的方式配置 bean 的名称。\n&lt;bean id=&quot;beanOne&quot; class=&quot;ExampleBean&quot; depends-on=&quot;manager,accountDao&quot;&gt;    &lt;property name=&quot;manager&quot; ref=&quot;manager&quot; /&gt;&lt;/bean&gt;&lt;bean id=&quot;manager&quot; class=&quot;ManagerBean&quot; /&gt;&lt;bean id=&quot;accountDao&quot; class=&quot;x.y.jdbc.JdbcAccountDao&quot; /&gt;\n\n懒加载一般情况下，容器创建的时候 bean 就会被加载，有时候不需要 bean 加载这么早，就可以使用懒加载，这时候 bean 会在获取的时候才被创建。\n&lt;bean id=&quot;lazy&quot; class=&quot;com.something.ExpensiveToCreateBean&quot; lazy-init=&quot;true&quot;/&gt;&lt;bean name=&quot;not.lazy&quot; class=&quot;com.something.AnotherBean&quot;/&gt;\n\n如果希望所有的 bean 都实现懒加载，那么可以将 beans 上的 default-lazy-init 属性设置为 true。\n&lt;beans default-lazy-init=&quot;true&quot;&gt;&lt;/beans&gt;\n\n方法注入属性中的 bean 只有一次注入的机会，后续使用的都是同一个 bean，有的时候我们希望每次可以使用不同的 bean，这个时候就可以用到方法注入。\nApplicationContextAware 接口实现上述需求的一种方法是实现 ApplicationContextAware 接口给 bean 注入容器，每次通过容器获取新的 bean，不过这种方法耦合度比较大，一般不推荐使用。\npublic class TeacherBean implements ApplicationContextAware &#123;    private ApplicationContext applicationContext;    public StudentBean student() &#123;        return (StudentBean) applicationContext.getBean(&quot;student&quot;);    &#125;    @Override    public void setApplicationContext(ApplicationContext applicationContext) throws BeansException &#123;        this.applicationContext = applicationContext;    &#125;&#125;\n\n查找方法注入Sping 可以通过重写字节码生成子类覆盖父类的方法实现注入。\npublic class TeacherBean  &#123;        public StudentBean student() &#123;        return null;    &#125;&#125;\n\n&lt;bean id=&quot;teacher&quot;  class=&quot;com.liang.bean.TeacherBean&quot;&gt;    &lt;lookup-method name=&quot;student&quot; bean=&quot;student&quot; /&gt;&lt;/bean&gt;&lt;bean id=&quot;student&quot; class=&quot;com.liang.bean.StudentBean&quot; scope=&quot;prototype&quot; /&gt;\n\n注入的方法签名应该满足如下格式：\n&lt;public|protected&gt; [abstract] &lt;return-type&gt; theMethodName(no-arguments);\n\nBean 的作用域在 bean 标签里可以设置 scope 属性设置 bean 的作用域，不同的作用域有不同的效果。\n&lt;bean id=&quot;ServiceImpl&quot; class=&quot;cn.csdn.service.ServiceImpl&quot; scope=&quot;singleton&quot;&gt;\n\n\nsingleton：默认的作用域，可以理解为单例模式，每个从容器中获得的 bean 都是同一个。\nprotptype：每次获取 bean 的时候，Spring 都会创建一个新的出来。\n\n除此以外还有 request、session、application 和 websocket 作用域，不过最常使用的还是 singleton 和 protptype 作用域。\n自定义 Bean 的性质生命周期回调在 Spring 框架内部使用 BeanPostProcessor 来处理它可以找到的任何回调接口并调用适当的方法，例如可以实现 Spring 的 InitializingBean 和 DisposableBean 接口。\n初始化回调如果我们想要在 bean 初始化的时候做一些事情，可以实现 InitializingBean 接口，Spring 会在设置完属性后调用 afterPropertiesSet 方法。\n&lt;bean id=&quot;exampleInitBean&quot; class=&quot;examples.AnotherExampleBean&quot;/&gt;\n\npublic class AnotherExampleBean implements InitializingBean &#123;    public void afterPropertiesSet() &#123;        // do some initialization work    &#125;&#125;\n\n上面这种情况耦合度比较大，Spring 提供了另一种可以实现相同功能的方式，init-method 可以用来指定一个方法，bean 属性设置完成后会执行该方法。\n&lt;bean id=&quot;exampleInitBean&quot; class=&quot;examples.ExampleBean&quot; init-method=&quot;init&quot;/&gt;\n\npublic class ExampleBean &#123;    public void init() &#123;        // do some initialization work    &#125;&#125;\n\n销毁回调和初始化回调一样，销毁时也可以做一些事情。\n&lt;bean id=&quot;exampleInitBean&quot; class=&quot;examples.AnotherExampleBean&quot;/&gt;\n\npublic class AnotherExampleBean implements DisposableBean &#123;    public void destroy() &#123;        // do some destruction work (like releasing pooled connections)    &#125;&#125;\n\nSpring 也提供了类似 init-method 的 destroy-method 方法，来实现解耦的目的。\n&lt;bean id=&quot;exampleInitBean&quot; class=&quot;examples.ExampleBean&quot; destroy-method=&quot;cleanup&quot;/&gt;\n\npublic class ExampleBean &#123;    public void cleanup() &#123;        // do some destruction work (like releasing pooled connections)    &#125;&#125;\n\n默认初始化和销毁回调在 beans 标签中可以使用 default-init-method 和 default-destroy-method 属性给所有 bean 设置默认的初始化合销毁回调，可以避免对每个 bean 都设置一遍。\n使用注解除了上面提到的，还可以使用 @PostConstruct 和 @PreDestroy 注解，不过首先需要开启注解，此处只要了解即可，对注解支持的介绍会在后续文章中。\n&lt;context:annotation-config/&gt;\n\n之后需要在方法上进行标注，其中 @PostConstruct 标注的方法会在属性设置后被执行，@PreDestroy 标注的方法会在 bean 被销毁前执行。\npublic class TeacherBean  &#123;    @PostConstruct    public void init() &#123;        System.out.println(&quot;init&quot;);    &#125;    @PostConstruct    public void close() &#123;        System.out.println(&quot;close&quot;);    &#125;&#125;\n\n一个 bean 如果使用不同的方法配置了生命周期函数，则每个函数都会被执行，如果是同名的函数，也会被执行多次。\nApplicationContextAwareApplicationContextAware 接口用于获取 ApplicationContext，在创建 bean 过程中，如果 bean 实现了 ApplicationContextAware 接口，Spring 会调用它的 setApplicationContext 方法。\npublic interface ApplicationContextAware &#123;    void setApplicationContext(ApplicationContext applicationContext) throws BeansException;&#125;\n\nBeanNameAware与 ApplicationContextAware 功能类似，如果一个实现了 BeanNameAware 接口，那么 Spring 会调用它的 setBeanName 方法，并将 bean 的 id 作为参数传入。\npublic interface BeanNameAware &#123;    void setBeanName(String name) throws BeansException;&#125;\n\n集成接口Spring 中可以通过插入特殊集成接口的实现来扩展 Spring IoC 容器。\n使用 BeanPostProcessor 自定义 BeanBeanPostProcessor 接口定义了回调方法，通过实现可以实现这些回调方法我们可以覆盖容器的默认的实例化逻辑、依赖项解析逻辑等。如果您想在 Spring 容器完成实例化，配置和初始化 bean 之后实现一些自定义逻辑，则可以插入一个或多个 BeanPostProcessor 实现。如果配置了多个 BeanPostProcessor 实例，可以通过设置 order 属性来控制这些 BeanPostProcessor 实例的执行顺序，这需要 BeanPostProcessor 实现 Ordered 接口。\npublic class MyBeanPostProcessor implements BeanPostProcessor &#123;    @Override    public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException &#123;        System.out.println(&quot;postProcessBeforeInitialization&quot;);        return bean;    &#125;    @Override    public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException &#123;        System.out.println(&quot;postProcessAfterInitialization&quot;);        return bean;    &#125;&#125;\n\n​ postProcessBeforeInitializationa 在 bean 属性注入之后、初始化之前执行，在该方法中可以用来修改已经注入的属性，或者返回全新的 bean 等，postProcessAfterInitialization 在 bean 初始化后执行。\n使用 BeanFactoryPostProcessor 自定义配置元数据BeanFactoryPostProcessor 接口的语义与 BeanPostProcessor 相似，但有一个主要区别：BeanFactoryPostProcessor 对 bean 配置元数据进行操作。也就是说，Spring IoC 容器允许 BeanFactoryPostProcessor 读取配置元数据，在 bean 实例化之前对 bean 的定义做出修改，比如改变 bean 的类型。如果配置多个 BeanFactoryPostProcessor，与 BeanPostProcessor 的情况类似。\nPropertyPlaceholderConfigurer 是一个 BeanFactoryPostProcessor 的实现类，它可以用来使用外部文件中的值来替代 Spring 配置文件中的值，例如下面配置数据库的例子。\n&lt;bean class=&quot;org.springframework.beans.factory.config.PropertyPlaceholderConfigurer&quot;&gt;    &lt;property name=&quot;locations&quot; value=&quot;classpath:com/something/jdbc.properties&quot;/&gt;&lt;/bean&gt;&lt;bean id=&quot;dataSource&quot; destroy-method=&quot;close&quot;        class=&quot;org.apache.commons.dbcp.BasicDataSource&quot;&gt;    &lt;property name=&quot;driverClassName&quot; value=&quot;$&#123;jdbc.driverClassName&#125;&quot;/&gt;    &lt;property name=&quot;url&quot; value=&quot;$&#123;jdbc.url&#125;&quot;/&gt;    &lt;property name=&quot;username&quot; value=&quot;$&#123;jdbc.username&#125;&quot;/&gt;    &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot;/&gt;&lt;/bean&gt;\n\n可以使用如下命名空间做为代替：\n&lt;context:property-placeholder location=&quot;classpath:com/something/jdbc.properties&quot;/&gt;\n\n使用 FactoryBean 自定义实例化逻辑对于一些初始化比较复杂的类，可以使用前面提到的 FactoryBean 注入到容器中，在调用 ApplicationContext 的 getBean() 方法时，如果想要获得 FactoryBean 本省，需要在 bean 的 id 前面加上一个符号 &amp;，如 getBean(&quot;&amp;myBean&quot;)。\n‍\n创建容器ClassPathXmlApplicationContext 是 ApplicationContext 类的一个实现，用来加载 xml 配置文件生成容器。\nClassPathXmlApplicationContext applicationContext = new ClassPathXmlApplicationContext(&quot;classpath:/bean.xml&quot;);Object student = applicationContext.getBean(&quot;student&quot;);System.out.println(student.getClass());\n\nBean 定义配置文件的一般形式如下，其中每一个 bean 标签都表示一个对象的定义，Spring 创建容器的过程中，会读取配置文件中的定义的 bean，之后可以根据 bean 中的各种信息创建对象实例。\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans        http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;         &lt;bean id=&quot;hello&quot; class=&quot;com.chang.Car&quot;&gt;        &lt;property name=&quot;name&quot; value=&quot;Spring&quot;/&gt;    &lt;/bean&gt;&lt;/beans&gt;\n\nid 属性每一个 bean 都有一个 id 属性，它是 bean 的唯一标识，可以通过 id 属性从容器中获得 bean，在同一个容器中所用的 id 属性应该是不同的。下面的例子展示了如和通过 id 获取对应的 bean。\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans        http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;         &lt;bean id=&quot;student&quot; class=&quot;com.chang.bean.Student&quot;&gt;        &lt;property name=&quot;name&quot; value=&quot;chang&quot;/&gt;    &lt;/bean&gt;&lt;/beans&gt;\n\nObject student = applicationContext.getBean(&quot;student&quot;);\n\n如果在 bean 的定义中没有指定 id 的化，Spring 会分配一个默认的 id 属性给该 bean，例如下面定义的 bean，Spring 给他的默认 id 可能为 com.liang.bean.Student#0。\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans        http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;         &lt;bean class=&quot;com.chang.bean.Student&quot;&gt;        &lt;property name=&quot;name&quot; value=&quot;chang&quot;/&gt;    &lt;/bean&gt;&lt;/beans&gt;\n\nclass 属性bean 标签中的 class 属性值为一个全类名，它表示该 bean 的类型，从容器中获取 bean 的时候，也可以根据类型来获取。\nObject student = applicationContext.getBean(Student.class);\n\nname 属性name 属性可以用来个 bean 起一个或多个别名，起多个别名的时候要用逗号、分号或空格隔开，如下所示：\n&lt;bean name=&quot;studentBean bean&quot; class=&quot;com.liang.bean.StudentBean&quot;/&gt;\n\nalias 属性alias 标签也可以用来给 bean 起别名，其中 alias 属性是别名，name 属性是对应该别名的 bean 的 id。\n&lt;alias name=&quot;fromName&quot; alias=&quot;toName&quot;/&gt;\n\n工厂方法创建 Bean前文中展示了 bean 最通常的配置方法，使用那样的配置时，创建 bean 时候是调用了对应类的构造方法。\n在有些代码中，为了实现程序的低耦合，创建实例的时候通常不会直接调用类的构造函数，而是使用一些工厂方法，针对这种情况，Spring 也提供了支持。\n静态工厂方法使用静态工厂方法创建 bean 实例时，class 属性也必须指定，但此时 class 属性并不是指定 bean 的类型，而是该 bean 对应的静态工厂类，因为 Spring 需要知道是用哪个工厂来创建 Bean 实例。另外，还需要使用 factory-method 属性来指定静态工厂方法名，Spring 将调用静态工厂方法，来返回一个 bean。一旦获得了指定 bean 实例，Spring 后面的处理步骤与采用普通方法创建 bean 实例则完全一样。需要注意的是，当使用静态工厂方法来创建 bean 时，这个 factory-method 必须要是静态的。\npublic class Car &#123;    private String name;    private int age;      public void setAge( int age) &#123;        this.age = age;    &#125;      public void setName(String name_) &#123;        this.name = name;    &#125;  &#125;\n\npublic class StaticFactory &#123;     public static Car getCar(String name) &#123;        Car car = new Car();        car.setName(name);        return car;   &#125; &#125;\n\n这里 constructor-arg 标签用于指定工厂方法需要的参数，property 标签用于注入属性，此处简单知道作用即刻，后面会对这两个标签详细展开。\n&lt;bean id=&quot;car&quot; class=&quot;com.liang.StaticFactory&quot; factory-method=&quot;getCar&quot;&gt;     &lt;constructor-arg value=&quot;Maserati&quot;/&gt;     &lt;property name=&quot;age&quot; value=&quot;12&quot;/&gt;&lt;/bean&gt;\n\n实例工厂方法既然有了静态工厂方法，那么必然会有实例工厂方法，两者的区别仅在于前者方法属于类，后者方法属于对象实例。\npublic class Car &#123;    private String name;    private int age;      public void setAge( int age) &#123;        this.age = age;    &#125;      public void setName(String name_) &#123;        this.name = name;    &#125;  &#125;\n\npublic class CarFactory &#123;     public Car getCar(String name) &#123;        Car car = new Car();        car.setName(name);        return car;   &#125; &#125;\n\n既然是实例工厂方法，那么首先需要创建出对应的实例，也就是下面第一行中的定义。之后再正真定义 bean 的时候，不在需要 class 属性了，而是需要使用 factory-bean 属性来指定工厂实例，同时使用 factory-method 指定定的工厂方法。如果工厂方法有参数或者需要在创建 bean 之后注入属性，也可以使用 constructor-arg 和 property 两个标签。\n&lt;bean id=&quot;carfactory&quot; class=&quot;com.liang.CarFactory&quot;&gt;&lt;/bean&gt;&lt;bean factory-bean=&quot;carfactory&quot; factory-method=&quot;getCar&quot;&gt;    &lt;constructor-arg value=&quot;Maserati&quot;/&gt;    &lt;property name=&quot;age&quot; value=&quot;12&quot;/&gt;&lt;/bean&gt;\n\nFactoryBeanSpring 中有两种类型的 bean，一种是普通的 bean，另一种是工厂 bean，即 FactoryBean。工厂 bean 跟普通 bean 不同，其返回的对象不是指定类的一个实例，而是该工厂 bean 的 getObject 方法返回的对象。\npublic interface FactortBean &#123;    //返回实例    Object getObject() throws Exception;    //返回类型    class getObjectType();    //返回的实例是否为单例    boolean isSingleton();&#125;\n\n上面是 FactoryBean 接口，下面我们看一下它的具体使用。\npublic class Car &#123;    private String name;    private int age;    public void setAge( int age) &#123;        this.age = age;    &#125;      public void setName(String name_) &#123;        this.name = name;    &#125;  &#125;\n\npublic class CarFactoryBean implements FactoryBean&#123;    private String name;    private int age;      public void setAge( int age) &#123;        this.age = age;    &#125;      public void setName(String name_) &#123;        this.name = name;    &#125;      public Object getObject() throws Exception &#123;        Car car = new Car();        car.setName(this.name);        car.setAge(this.age);        return car;    &#125;       public Class&lt;?&gt; getObjectType() &#123;  //注意这个方法主要作用是：该方法返回的类型是在ioc容器中getbean所匹配的类型        return Car.class;    &#125;      public boolean isSingleton() &#123;        return true;    &#125;&#125;\n\n我们在定义中没有添加 Car，而是直接在容器中添加了一个 CarFactoryBean，不过如果从容器中获取 id 为 car 的 bean 时，获得并不是 CarFactoryBean 的实例，而是 Car 的实例。这是应为 Spring 首先创建了一个 CarFactoryBean 的实例，然后调用了 getObject 方法获取返回值，并将该返回值作为 id 对应的实例。\n&lt;bean id=&quot;car&quot; class=&quot;com.liang.CarFactoryBean&quot;&gt;     &lt;property name=&quot;name&quot; value=&quot;chang&quot;/&gt;     &lt;property name=&quot;age&quot; value=&quot;12&quot;/&gt;&lt;/bean&gt;\n\n导入其他配置在一个项目中，Spring 可能会管理分属不同业务的 bean，如果将所有的 bean 定义在同一个配置文件中，会显得比较混乱。那么可以将不同业务的 bean 定义在不同的配置文件中，然后再将其汇总。通过下面的方式，可以导入其他的配置到当前配置中。\n&lt;beans&gt;    &lt;import resource=&quot;services.xml&quot;/&gt;    &lt;import resource=&quot;resources/messageSource.xml&quot;/&gt;    &lt;import resource=&quot;/resources/themeSource.xml&quot;/&gt;    &lt;bean id=&quot;bean1&quot; class=&quot;...&quot;/&gt;    &lt;bean id=&quot;bean2&quot; class=&quot;...&quot;/&gt;&lt;/beans&gt;\n\n所有路径都相对于当前配置文件，因此 services.xml 必须与进行导入的文件位于同一目录或位置，而 messageSource.xml 和 themeSource.xml 必须位于导入文件位置下方的 resources 位置开头的斜杠会被忽略，所以通常建议省去斜杠。\n除了使用相对路径，还可以使用 classpath:/com/liang/bean.xml 以及 file:C:/config/services.xml 这样的绝对路径。\n不同配置文件中的 bean 如果有相同的 id，即使是不相同的类，先定义的会把后定义的类覆盖掉。\n除了使用这种方法汇总不同的配置文件，在创建容器的时候也支持添加多个文件，如下面的代码所示。\nClassPathXmlApplicationContext applicationContext = new ClassPathXmlApplicationContext(&quot;classpath:/bean.xml&quot;, &quot;classpath:/bean2.xml&quot;);\n\n依赖注入所谓的依赖注入，简单的理解就是给实例中的属性赋值，比如下面的类，在创建了对象之后，通常要对 age 和 name 两个属性赋值。\npublic class Car &#123;    private String name;    private int age;    public Car() &#123;     &#125;    public Car(String name, int age) &#123;        this.name = name;        this.age = age;    &#125;      public void setAge( int age) &#123;        this.age = age;    &#125;      public void setName(String name_) &#123;        this.name = name;    &#125;  &#125;\n\n在 Sping 中有两种依赖注入的方式，一种是通过构造函数，一种是通过 setter 方法，也就是对应了我们编程时给对象属性赋值的两种方法。\nCar carOne = new Car(&quot;chang&quot;, 12);Car carTwo = new Car();carTwo.setName(&quot;liang&quot;);carTwo.setAge(13);\n\n调用的带参数的构造方法创建对象实例后，任然可以使用 set 方法更新属性值，所以在 Spring 中 setter 方法可用于覆盖构造函数中配置的依赖，构造函数一般用于强制性依赖，setter 方法用于可选依赖。\n基于构造函数注入public class TeacherBean &#123;    private String name;        private StudentBean student;    public TeacherBean(String name, StudentBean student) &#123;        this.name = name;        this.student = student;    &#125;&#125;\n\n当类的属性是通过构造函数赋值的时候，在定义 bean 的时候就需要基于构造函数将属性注入，通常配置如下：\n&lt;beans&gt;    &lt;bean id=&quot;teacher&quot; class=&quot;con.liang.TeacherBean&quot;&gt;        &lt;constructor-arg value=&quot;chang&quot;/&gt;        &lt;constructor-arg ref=&quot;student&quot;/&gt;    &lt;/bean&gt;    &lt;bean id=&quot;student&quot; class=&quot;com.liang.StudentBean&quot;/&gt;&lt;/beans&gt;\n\n其中 &lt;constructor-arg value=&quot;chang&quot;/&gt; 指定一个基本类型的参数，&lt;constructor-arg ref=&quot;student&quot;/&gt; 指定一个对象。\n上面的示例中两个参数比较容易区分，如果两个参数都是基本类型或属于同一个类，则需要额外属性进行辅助，看下面的例子：\npublic class TeacherBean &#123;    private String name;    private int age;    public TeacherBean(String name, int age) &#123;        this.name = name;        this.age = age;    &#125;&#125;\n\n\n可以通过 type 指定类型进行区分。\n这个时候如果还是只用不带任何属性的 canstructor-arg 标签的话，Spring 是无法分清楚 1 这个值时赋给 name 还是 age 的，因为无法区分 1 这个字面值到底是数字还是字符串。\n&lt;bean id=&quot;teacher&quot;  class=&quot;com.liang.bean.TeacherBean&quot;&gt;    &lt;constructor-arg value=&quot;1&quot;/&gt;    &lt;constructor-arg value=&quot;2&quot;/&gt;&lt;/bean&gt;\n\n使用 type 属性就可以解决这个问题，下面的配置中就明确指明了 1 要赋给一个字符串类型，但这种方法也有缺点，如果多个参数类型相同的话，就无法使用了。\n&lt;bean id=&quot;teacher&quot;  class=&quot;com.liang.bean.TeacherBean&quot;&gt;    &lt;constructor-arg type=&quot;java.lang.String&quot; value=&quot;1&quot;/&gt;    &lt;constructor-arg type=&quot;int&quot; value=&quot;2&quot;/&gt;&lt;/bean&gt;\n\n可以指定索引进行区分。\n这个方法比较好理解，直接使用参数在参数列表中的序号定位即可，比如下面的配置，将 1 赋给 0 号位的参数。\n&lt;bean id=&quot;teacher&quot;  class=&quot;com.liang.bean.TeacherBean&quot;&gt;    &lt;constructor-arg index=&quot;0&quot; value=&quot;1&quot;/&gt;    &lt;constructor-arg index=&quot;1&quot; value=&quot;2&quot;/&gt;&lt;/bean&gt;\n\n可以指定属性名进行区分。\n这个也是比较清晰，使用参数名来对应值。\n&lt;bean id=&quot;teacher&quot;  class=&quot;com.liang.bean.TeacherBean&quot;&gt;    &lt;constructor-arg name=&quot;name&quot; value=&quot;1&quot;/&gt;    &lt;constructor-arg name=&quot;age&quot; value=&quot;2&quot;/&gt;&lt;/bean&gt;\n\n基于 Setter 注入在不通过构造方法注入时，Spring 需要首先调用类中无参数的构造函数进行实例化，之后再通过 setter 方法注入属性，所以必须保证无参数的构造函数以及 setter 方法存在。\npublic class TeacherBean &#123;    private String name;    private int age;   &#125;\n\n对于上面的这个类，如果需要实现属性注入，配置如下：\n&lt;bean id=&quot;teacher&quot;  class=&quot;com.liang.bean.TeacherBean&quot;&gt;    &lt;property name=&quot;name&quot; value=&quot;12&quot; /&gt;    &lt;property name=&quot;age&quot; value=&quot;122&quot; /&gt;&lt;/bean&gt;\n\n如果注入的属性时一个对象时，可以使用 ​ &lt;property name=&quot;student&quot; ref=&quot;student&quot; /&gt; 这样的方式：\n&lt;beans&gt;    &lt;bean id=&quot;teacher&quot; class=&quot;con.liang.TeacherBean&quot;&gt;        &lt;property name=&quot;name&quot; value=&quot;12&quot; /&gt;        &lt;property name=&quot;student&quot; ref=&quot;student&quot; /&gt;    &lt;/bean&gt;    &lt;bean id=&quot;student&quot; class=&quot;com.liang.StudentBean&quot;/&gt;&lt;/beans&gt;\n\n注入配置细节常量注入\n字面值: 可用字符串表示的值，可以通过 value 属性或标签进行注入。\n&lt;bean id=&quot;teacher&quot;  class=&quot;com.liang.bean.TeacherBean&quot;&gt;       &lt;property name=&quot;name&quot; value=&quot;12&quot; /&gt;       &lt;property name=&quot;age&quot;&gt;               &lt;value&gt;12&lt;/value&gt;       &lt;/property &gt;&lt;/bean&gt;\n\n支持将 value 标签中的字符串转化为 java.util.Properties 类\n&lt;!-- typed as a java.util.Properties --&gt;&lt;property name=&quot;properties&quot;&gt;    &lt;value&gt;        jdbc.driver.className=com.mysql.jdbc.Driver        jdbc.url=jdbc:mysql://localhost:3306/mydb    &lt;/value&gt;&lt;/property&gt;\n\n基本数据类型及其封装类、String 等类型都可以采取字面值注入的方式\n\n若字面值中包含特殊字符，可以使用  把字面值包裹起来。\n\n\nBean 注入\n可以用 ref 属性或标签引入外部类\n&lt;bean id=&quot;addr&quot; class=&quot;com.chang.pojo.Address&quot;&gt;    &lt;property name=&quot;address&quot; value=&quot;重庆&quot;/&gt;&lt;/bean&gt;&lt;!-- 使用ref属性 --&gt;&lt;bean id=&quot;student&quot; class=&quot;com.chang.pojo.Student&quot;&gt;    &lt;property name=&quot;name&quot; value=&quot;小明&quot;/&gt;    &lt;property name=&quot;address&quot; ref=&quot;addr&quot;/&gt;&lt;/bean&gt;&lt;!-- 使用标签 --&gt;&lt;bean id=&quot;student&quot; class=&quot;com.chang.pojo.Student&quot;&gt;    &lt;property name=&quot;name&quot; value=&quot;小明&quot;/&gt;    &lt;property name=&quot;address&quot;&gt;        &lt;ref bean=&quot;addr&quot;/&gt;    &lt;/property&gt;&lt;/bean&gt;\n\n用 ref 标签的 parent 属性可以从父容器中获的 bean\n&lt;!-- in the parent context --&gt;&lt;bean id=&quot;accountService&quot; class=&quot;com.something.SimpleAccountService&quot;&gt;    &lt;!-- insert dependencies as required as here --&gt;&lt;/bean&gt;\n\n&lt;!-- in the child (descendant) context --&gt;&lt;bean id=&quot;accountService&quot; &lt;!-- bean name is the same as the parent bean --&gt;    class=&quot;org.springframework.aop.framework.ProxyFactoryBean&quot;&gt;    &lt;property name=&quot;target&quot;&gt;        &lt;ref parent=&quot;accountService&quot;/&gt; &lt;!-- notice how we refer to the parent bean --&gt;    &lt;/property&gt;    &lt;!-- insert other configuration and dependencies as required here --&gt;&lt;/bean&gt;\n\n可以使用 idref 代替 ref 标签\n使用 idref 标签在容器部署的时候会验证 bean 是否存在。\n&lt;bean id=&quot;theTargetBean&quot; class=&quot;...&quot;/&gt;&lt;bean id=&quot;theClientBean&quot; class=&quot;...&quot;&gt;    &lt;property name=&quot;targetName&quot;&gt;        &lt;idref bean=&quot;theTargetBean&quot;/&gt;    &lt;/property&gt;&lt;/bean&gt;\n\n可以使用内部类\n&lt;bean id=&quot;student&quot; class=&quot;com.chang.pojo.Student&quot;&gt;    &lt;property name=&quot;name&quot; value=&quot;小明&quot;/&gt;    &lt;property name=&quot;address&quot;&gt;        &lt;bean id=&quot;addr&quot; class=&quot;com.chang.pojo.Address&quot;&gt;            &lt;property name=&quot;address&quot; value=&quot;重庆&quot;/&gt;    &lt;/bean&gt;    &lt;/property&gt;&lt;/bean&gt;\n\n内部类不用指明 id 和 name 属性，但不能用于其他地方。\n\nSpring 支持使用级联属性赋值。\n&lt;bean id=&quot;addr&quot; class=&quot;com.chang.pojo.Address&quot;&gt;    &lt;property name=&quot;address&quot; value=&quot;重庆&quot;/&gt;&lt;/bean&gt;&lt;bean id=&quot;student&quot; class=&quot;com.chang.pojo.Student&quot;&gt;    &lt;property name=&quot;name&quot; value=&quot;小明&quot;/&gt;    &lt;property name=&quot;address&quot; ref=&quot;addr&quot;/&gt;    &lt;property name=&quot;adderss.address&quot; value=&quot;重庆&quot;/&gt;&lt;/bean&gt;\n\n数组注入&lt;bean id=&quot;student&quot; class=&quot;com.kuang.pojo.Student&quot;&gt;    &lt;property name=&quot;name&quot; value=&quot;小明&quot;/&gt;    &lt;property name=&quot;address&quot; ref=&quot;addr&quot;/&gt;    &lt;property name=&quot;books&quot;&gt;        &lt;array&gt;            &lt;value&gt;西游记&lt;/value&gt;            &lt;value&gt;红楼梦&lt;/value&gt;            &lt;value&gt;水浒传&lt;/value&gt;        &lt;/array&gt;    &lt;/property&gt;&lt;/bean&gt;\n\nList 注入&lt;property name=&quot;someList&quot;&gt;    &lt;list&gt;        &lt;value&gt;a list element followed by a reference&lt;/value&gt;        &lt;ref bean=&quot;myDataSource&quot; /&gt;    &lt;/list&gt;&lt;/property&gt;\n\nMap 注入&lt;property name=&quot;someMap&quot;&gt;    &lt;map&gt;        &lt;entry key=&quot;an entry&quot; value=&quot;just some string&quot;/&gt;        &lt;entry key =&quot;a ref&quot; value-ref=&quot;myDataSource&quot;/&gt;    &lt;/map&gt;&lt;/property&gt;\n\nset 注入&lt;property name=&quot;someSet&quot;&gt;    &lt;set&gt;        &lt;value&gt;just some string&lt;/value&gt;        &lt;ref bean=&quot;myDataSource&quot; /&gt;    &lt;/set&gt;&lt;/property&gt;\n\nProperties 注入&lt;property name=&quot;info&quot;&gt;    &lt;props&gt;        &lt;prop key=&quot;学号&quot;&gt;20190604&lt;/prop&gt;        &lt;prop key=&quot;性别&quot;&gt;男&lt;/prop&gt;        &lt;prop key=&quot;姓名&quot;&gt;小明&lt;/prop&gt;    &lt;/props&gt;&lt;/property&gt;\n\n集合合并bean 标签中有一个属性为 abstract，默认情况下该值为 false，如果将他设置为 true 的话，那么容器将不会创建它的实例。它需要和 parent 配合使用，姑且可以将 abstrcat 属性的 bean 称为父 bean，将带有 parent 属性的 bean 称为子 bean，父 bean 中的 property 标签会被继承到子 bean 中，比如下面的例子中，&lt;property name=&quot;name&quot; value = &quot;chang&quot;/&gt; 会被自动添加到子 bean 中。\n&lt;beans&gt;    &lt;bean id=&quot;parent&quot; abstract=&quot;true&quot; class=&quot;example.ComplexObject&quot;&gt;        &lt;property name=&quot;name&quot; value = &quot;chang&quot;/&gt;        &lt;property name=&quot;adminEmails&quot;&gt;            &lt;props&gt;                &lt;prop key=&quot;administrator&quot;&gt;[emailprotected]&lt;/prop&gt;                &lt;prop key=&quot;support&quot;&gt;[emailprotected]&lt;/prop&gt;            &lt;/props&gt;        &lt;/property&gt;    &lt;/bean&gt;    &lt;bean id=&quot;child&quot; parent=&quot;parent&quot;&gt;        &lt;property name=&quot;adminEmails&quot;&gt;            &lt;!-- the merge is specified on the child collection definition --&gt;            &lt;props merge=&quot;true&quot;&gt;                &lt;prop key=&quot;sales&quot;&gt;[emailprotected]&lt;/prop&gt;                &lt;prop key=&quot;support&quot;&gt;[emailprotected]&lt;/prop&gt;            &lt;/props&gt;        &lt;/property&gt;    &lt;/bean&gt;&lt;beans&gt;\n\n子 bean 如果和父 bean 定义了相同的属性，那么后者会把前者的值覆盖。不过如果属性是集合的话，可以开启集合的合并行为，目前合并行为适用于 &lt;list/&gt;，&lt;map/&gt;、&lt;set/&gt; 和 &lt;properties&gt; 集合类型，需要做的是将 merge 属性设置为 true。\n在合并 List 元素时父 bean 的值位于所有子级列表的值之前，对于 Map，Set 和 Properties 集合类型，会继承所有父级中的元素，对于 key 相同的元素会进行覆盖。\n空字符串和 null 值注入&lt;!-- 等价于 wife = null --&gt;&lt;property name=&quot;wife&quot;&gt;&lt;null/&gt;&lt;/property&gt;&lt;!-- 等价于 email = &quot;&quot; --&gt;&lt;property name=&quot;email&quot; value=&quot;&quot;/&gt;\n\n注入拓展: P 命名空间在 beans 中添加 xmlns:p=&quot;http://www.springframework.org/schema/p&quot; 可以开启 P 命名空间，作用是可以使用类似 p:email 的属性替代 property 标签。\n&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;    xmlns:p=&quot;http://www.springframework.org/schema/p&quot;    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans        http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;    &lt;bean name=&quot;classic&quot; class=&quot;com.example.ExampleBean&quot;&gt;        &lt;property name=&quot;email&quot; value=&quot;[emailprotected]&quot;/&gt;    &lt;/bean&gt;    &lt;bean name=&quot;p-namespace&quot; class=&quot;com.example.ExampleBean&quot;        p:email=&quot;[emailprotected]&quot;/&gt;&lt;/beans&gt;\n\n注入拓展: c 命名空间在 beans 中添加 xmlns:c=&quot;http://www.springframework.org/schema/c&quot; 可以开启 C 命名空间，作用是使用类似 c:thingTwo-ref 的属性替代 constructor-arg 标签。\n&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;    xmlns:c=&quot;http://www.springframework.org/schema/c&quot;    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans        http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;    &lt;bean id=&quot;thingOne&quot; class=&quot;x.y.ThingTwo&quot;/&gt;    &lt;bean id=&quot;thingTwo&quot; class=&quot;x.y.ThingThree&quot;/&gt;    &lt;!-- traditional declaration --&gt;    &lt;bean id=&quot;thingOne&quot; class=&quot;x.y.ThingOne&quot;&gt;        &lt;constructor-arg ref=&quot;thingTwo&quot;/&gt;        &lt;constructor-arg ref=&quot;thingThree&quot;/&gt;        &lt;constructor-arg value=&quot;[emailprotected]&quot;/&gt;    &lt;/bean&gt;    &lt;!-- c-namespace declaration --&gt;    &lt;bean id=&quot;thingOne&quot; class=&quot;x.y.ThingOne&quot; c:thingTwo-ref=&quot;thingTwo&quot; c:thingThree-ref=&quot;thingThree&quot; c:email=&quot;[emailprotected]&quot;/&gt;&lt;/beans&gt;\n\nutil 里的集合标签使用基本的集合标签定义集合时 , 不能将集合作为独立的 bean 定义 , 导致其他 bean 无法引用该集合 , 无法让集合在不同 bean 之间共享。在 beans 中添加 xmlns:util=&quot;http://www.springframework.org/schema/util&quot; 可以开启集合标签，它实现了集合类型的独立定义。\n&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;    xmlns:util=&quot;http://www.springframework.org/schema/util&quot;    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans        http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;    &lt;util:list id=&quot;list&quot;&gt;        &lt;ref bean=&quot;car1&quot;/&gt;        &lt;ref bean=&quot;car2&quot;/&gt;        &lt;ref bean=&quot;car3&quot;/&gt;         &lt;ref bean=&quot;car4&quot;/&gt;    &lt;/util:list&gt;    &lt;bean id=&quot;car1&quot; class=&quot;com.chang.Car&quot;&gt;&lt;/bean&gt;    &lt;bean id=&quot;car2&quot; class=&quot;com.chang.Car&quot;&gt;&lt;/bean&gt;    &lt;bean id=&quot;car3&quot; class=&quot;com.chang.Car&quot;&gt;&lt;/bean&gt;    &lt;bean id=&quot;car4&quot; class=&quot;com.chang.Car&quot;&gt;&lt;/bean&gt;      &lt;bean id=&quot;person&quot; class=&quot;com.chang.Person&quot;&gt;        &lt;property name=&quot;car&quot; ref=&quot;list&quot;/&gt;    &lt;/bean&gt;&lt;/beans&gt;\n\n自动装配Spring 容器可以自动装配 bean，需要使用 autowire 属性里指定自动装配的模式。这个自动装配可以简单的理解为，如果一个 bean 的某个属性类型为 A，当容器中存在一个类型为 A 的 bean 时，Spirng 可以自动将 A 类型的 bean 赋给该属性。\npublic class User &#123;    private Car car;&#125;public class Car &#123;&#125;\n\n在下面的配置中，id 为 car 的 bean 会自动被赋给 user 的 car 属性。\n&lt;bean id=&quot;user&quot; class=&quot;com.liang.User&quot; autowire=&quot;byName&quot;&gt;&lt;/bean&gt;&lt;bean id=&quot;car&quot; class=&quot;com.liang.Car&quot;&gt;&lt;/bean&gt;\n\nautowire 的可选值有多个，分别代表不同的装配模式：\n\nno：默认值，表示不进行自动装配，所有的 bean 引用必须由手动定义。对于大型部署，建议不要更改默认设置，因为明确指定协作者可以提供更好的控制和清晰度，在某种程度上，它记录了系统的结构。\nbyName：按属性名称自动装配，Spring 会寻找与属性同名的 bean。例如，如果一个 bean 包含一个 master 属性，那么 Spring 将查找一个名为 master 的 bean 来为它赋值。\nbyType：与 byName 类似，只不过它查找 bean 的依据是属性的类型。\nconstructor：类似于 byType，但它适用于构造函数的情况。\n\n在 byType 或 constructor 自动装配模式下，可以自动按类型装配数组或集合。如果使用的是 map 并且 key 是 String 类型，则使用 bean 的 id 属性作为 key。\npublic class TeacherBean &#123;   private StudentBean[] students;    public void setStudents(StudentBean[] students) &#123;        this.students = students;    &#125;&#125;public class StudentBean &#123;&#125;\n\n&lt;bean id=&quot;teacher&quot;  class=&quot;com.liang.bean.TeacherBean&quot; autowire=&quot;byType&quot; /&gt;&lt;bean class=&quot;com.liang.bean.StudentBean&quot;/&gt;&lt;bean class=&quot;com.liang.bean.StudentBean&quot;/&gt;\n\nbean 中还有一个属性 autowire-candidate，将它设置为 false 后，该 bean 不参与按类型自动装配，但是不影响按名字装配。\n&lt;bean class=&quot;com.liang.bean.StudentBean&quot; autowire-candidate=&quot;false&quot;/&gt;\n\n继承和依赖继承Spring 允许继承 bean 的配置，被继承的 bean 称为父 ​ bean，继承这个父 Bean 的 Bean ​ 称为子 Bean，前面在集合合并中简单的提过，这里详细讲解一下。子 bean ​ 从父 bean ​ 中继承配置，包括 bean 的属性配置，子 bean 也可以覆盖从父 bean 继承过来的配置。父 bean 可以作为配置模板，也可以作为 bean 实例。若只想把父 bean 作为模板, 可以设置 bean 的 abstract ​ 属性为 ​ true，这样 Spring 将不会实例化这个 bean，并不是 bean 元素里的所有属性都会被继承，比如: autowire, abstract 等。\n&lt;bean id=&quot;parent&quot; abstract=&quot;true&quot;&gt;    &lt;property name=&quot;parentName&quot;&gt;        &lt;value&gt;&lt;/value&gt;    &lt;/property&gt;&lt;/bean&gt;&lt;bean id=&quot;child&quot; class=&quot;com.spring.auto.autowire.Parent&quot; parent=&quot;parent&quot;&gt;    &lt;property name=&quot;parentName&quot;&gt;        &lt;value&gt;抽象类实现&lt;/value&gt;    &lt;/property&gt;&lt;/bean&gt;\n\n依赖Spring 允许用户通过 depends-on 属性设定 bean 前置依赖的 bean，前置依赖的 bean 会在本 bean 实例化之前创建好。如果前置依赖于多个 bean，则可以通过逗号，空格隔开的方式配置 bean 的名称。\n&lt;bean id=&quot;beanOne&quot; class=&quot;ExampleBean&quot; depends-on=&quot;manager,accountDao&quot;&gt;    &lt;property name=&quot;manager&quot; ref=&quot;manager&quot; /&gt;&lt;/bean&gt;&lt;bean id=&quot;manager&quot; class=&quot;ManagerBean&quot; /&gt;&lt;bean id=&quot;accountDao&quot; class=&quot;x.y.jdbc.JdbcAccountDao&quot; /&gt;\n\n懒加载一般情况下，容器创建的时候 bean 就会被加载，有时候不需要 bean 加载这么早，就可以使用懒加载，这时候 bean 会在获取的时候才被创建。\n&lt;bean id=&quot;lazy&quot; class=&quot;com.something.ExpensiveToCreateBean&quot; lazy-init=&quot;true&quot;/&gt;&lt;bean name=&quot;not.lazy&quot; class=&quot;com.something.AnotherBean&quot;/&gt;\n\n如果希望所有的 bean 都实现懒加载，那么可以将 beans 上的 default-lazy-init 属性设置为 true。\n&lt;beans default-lazy-init=&quot;true&quot;&gt;&lt;/beans&gt;\n\n方法注入属性中的 bean 只有一次注入的机会，后续使用的都是同一个 bean，有的时候我们希望每次可以使用不同的 bean，这个时候就可以用到方法注入。\nApplicationContextAware 接口实现上述需求的一种方法是实现 ApplicationContextAware 接口给 bean 注入容器，每次通过容器获取新的 bean，不过这种方法耦合度比较大，一般不推荐使用。\npublic class TeacherBean implements ApplicationContextAware &#123;    private ApplicationContext applicationContext;    public StudentBean student() &#123;        return (StudentBean) applicationContext.getBean(&quot;student&quot;);    &#125;    @Override    public void setApplicationContext(ApplicationContext applicationContext) throws BeansException &#123;        this.applicationContext = applicationContext;    &#125;&#125;\n\n查找方法注入Sping 可以通过重写字节码生成子类覆盖父类的方法实现注入。\npublic class TeacherBean  &#123;        public StudentBean student() &#123;        return null;    &#125;&#125;\n\n&lt;bean id=&quot;teacher&quot;  class=&quot;com.liang.bean.TeacherBean&quot;&gt;    &lt;lookup-method name=&quot;student&quot; bean=&quot;student&quot; /&gt;&lt;/bean&gt;&lt;bean id=&quot;student&quot; class=&quot;com.liang.bean.StudentBean&quot; scope=&quot;prototype&quot; /&gt;\n\n注入的方法签名应该满足如下格式：\n&lt;public|protected&gt; [abstract] &lt;return-type&gt; theMethodName(no-arguments);\n\nBean 的作用域在 bean 标签里可以设置 scope 属性设置 bean 的作用域，不同的作用域有不同的效果。\n&lt;bean id=&quot;ServiceImpl&quot; class=&quot;cn.csdn.service.ServiceImpl&quot; scope=&quot;singleton&quot;&gt;\n\n\nsingleton：默认的作用域，可以理解为单例模式，每个从容器中获得的 bean 都是同一个。\nprotptype：每次获取 bean 的时候，Spring 都会创建一个新的出来。\n\n除此以外还有 request、session、application 和 websocket 作用域，不过最常使用的还是 singleton 和 protptype 作用域。\n自定义 Bean 的性质生命周期回调在 Spring 框架内部使用 BeanPostProcessor 来处理它可以找到的任何回调接口并调用适当的方法，例如可以实现 Spring 的 InitializingBean 和 DisposableBean 接口。\n初始化回调如果我们想要在 bean 初始化的时候做一些事情，可以实现 InitializingBean 接口，Spring 会在设置完属性后调用 afterPropertiesSet 方法。\n&lt;bean id=&quot;exampleInitBean&quot; class=&quot;examples.AnotherExampleBean&quot;/&gt;\n\npublic class AnotherExampleBean implements InitializingBean &#123;    public void afterPropertiesSet() &#123;        // do some initialization work    &#125;&#125;\n\n上面这种情况耦合度比较大，Spring 提供了另一种可以实现相同功能的方式，init-method 可以用来指定一个方法，bean 属性设置完成后会执行该方法。\n&lt;bean id=&quot;exampleInitBean&quot; class=&quot;examples.ExampleBean&quot; init-method=&quot;init&quot;/&gt;\n\npublic class ExampleBean &#123;    public void init() &#123;        // do some initialization work    &#125;&#125;\n\n销毁回调和初始化回调一样，销毁时也可以做一些事情。\n&lt;bean id=&quot;exampleInitBean&quot; class=&quot;examples.AnotherExampleBean&quot;/&gt;\n\npublic class AnotherExampleBean implements DisposableBean &#123;    public void destroy() &#123;        // do some destruction work (like releasing pooled connections)    &#125;&#125;\n\nSpring 也提供了类似 init-method 的 destroy-method 方法，来实现解耦的目的。\n&lt;bean id=&quot;exampleInitBean&quot; class=&quot;examples.ExampleBean&quot; destroy-method=&quot;cleanup&quot;/&gt;\n\npublic class ExampleBean &#123;    public void cleanup() &#123;        // do some destruction work (like releasing pooled connections)    &#125;&#125;\n\n默认初始化和销毁回调在 beans 标签中可以使用 default-init-method 和 default-destroy-method 属性给所有 bean 设置默认的初始化合销毁回调，可以避免对每个 bean 都设置一遍。\n使用注解除了上面提到的，还可以使用 @PostConstruct 和 @PreDestroy 注解，不过首先需要开启注解，此处只要了解即可，对注解支持的介绍会在后续文章中。\n&lt;context:annotation-config/&gt;\n\n之后需要在方法上进行标注，其中 @PostConstruct 标注的方法会在属性设置后被执行，@PreDestroy 标注的方法会在 bean 被销毁前执行。\npublic class TeacherBean  &#123;    @PostConstruct    public void init() &#123;        System.out.println(&quot;init&quot;);    &#125;    @PostConstruct    public void close() &#123;        System.out.println(&quot;close&quot;);    &#125;&#125;\n\n一个 bean 如果使用不同的方法配置了生命周期函数，则每个函数都会被执行，如果是同名的函数，也会被执行多次。\nApplicationContextAwareApplicationContextAware 接口用于获取 ApplicationContext，在创建 bean 过程中，如果 bean 实现了 ApplicationContextAware 接口，Spring 会调用它的 setApplicationContext 方法。\npublic interface ApplicationContextAware &#123;    void setApplicationContext(ApplicationContext applicationContext) throws BeansException;&#125;\n\nBeanNameAware与 ApplicationContextAware 功能类似，如果一个实现了 BeanNameAware 接口，那么 Spring 会调用它的 setBeanName 方法，并将 bean 的 id 作为参数传入。\npublic interface BeanNameAware &#123;    void setBeanName(String name) throws BeansException;&#125;\n\n集成接口Spring 中可以通过插入特殊集成接口的实现来扩展 Spring IoC 容器。\n使用 BeanPostProcessor 自定义 BeanBeanPostProcessor 接口定义了回调方法，通过实现可以实现这些回调方法我们可以覆盖容器的默认的实例化逻辑、依赖项解析逻辑等。如果您想在 Spring 容器完成实例化，配置和初始化 bean 之后实现一些自定义逻辑，则可以插入一个或多个 BeanPostProcessor 实现。如果配置了多个 BeanPostProcessor 实例，可以通过设置 order 属性来控制这些 BeanPostProcessor 实例的执行顺序，这需要 BeanPostProcessor 实现 Ordered 接口。\npublic class MyBeanPostProcessor implements BeanPostProcessor &#123;    @Override    public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException &#123;        System.out.println(&quot;postProcessBeforeInitialization&quot;);        return bean;    &#125;    @Override    public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException &#123;        System.out.println(&quot;postProcessAfterInitialization&quot;);        return bean;    &#125;&#125;\n\n​ postProcessBeforeInitializationa 在 bean 属性注入之后、初始化之前执行，在该方法中可以用来修改已经注入的属性，或者返回全新的 bean 等，postProcessAfterInitialization 在 bean 初始化后执行。\n使用 BeanFactoryPostProcessor 自定义配置元数据BeanFactoryPostProcessor 接口的语义与 BeanPostProcessor 相似，但有一个主要区别：BeanFactoryPostProcessor 对 bean 配置元数据进行操作。也就是说，Spring IoC 容器允许 BeanFactoryPostProcessor 读取配置元数据，在 bean 实例化之前对 bean 的定义做出修改，比如改变 bean 的类型。如果配置多个 BeanFactoryPostProcessor，与 BeanPostProcessor 的情况类似。\nPropertyPlaceholderConfigurer 是一个 BeanFactoryPostProcessor 的实现类，它可以用来使用外部文件中的值来替代 Spring 配置文件中的值，例如下面配置数据库的例子。\n&lt;bean class=&quot;org.springframework.beans.factory.config.PropertyPlaceholderConfigurer&quot;&gt;    &lt;property name=&quot;locations&quot; value=&quot;classpath:com/something/jdbc.properties&quot;/&gt;&lt;/bean&gt;&lt;bean id=&quot;dataSource&quot; destroy-method=&quot;close&quot;        class=&quot;org.apache.commons.dbcp.BasicDataSource&quot;&gt;    &lt;property name=&quot;driverClassName&quot; value=&quot;$&#123;jdbc.driverClassName&#125;&quot;/&gt;    &lt;property name=&quot;url&quot; value=&quot;$&#123;jdbc.url&#125;&quot;/&gt;    &lt;property name=&quot;username&quot; value=&quot;$&#123;jdbc.username&#125;&quot;/&gt;    &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot;/&gt;&lt;/bean&gt;\n\n可以使用如下命名空间做为代替：\n&lt;context:property-placeholder location=&quot;classpath:com/something/jdbc.properties&quot;/&gt;\n\n使用 FactoryBean 自定义实例化逻辑对于一些初始化比较复杂的类，可以使用前面提到的 FactoryBean 注入到容器中，在调用 ApplicationContext 的 getBean() 方法时，如果想要获得 FactoryBean 本省，需要在 bean 的 id 前面加上一个符号 &amp;，如 getBean(&quot;&amp;myBean&quot;)。\n","categories":["Spring学习笔记"],"tags":["Spring"]},{"title":"Spring的一些高级配置.md","url":"/2023/03/15/Spring%E7%9A%84%E4%B8%80%E4%BA%9B%E9%AB%98%E7%BA%A7%E9%85%8D%E7%BD%AE/","content":"设置 Profile在实际的开发过程中，可能区分为开发环境、测试环境和生产环境，不同的环境中使用的 Bean 可能不同，Spring 中提供了 @Profile 注解来实现这一需求，该注解可用于类和方法。\n@Configuration@Profile(&quot;development&quot;)public class StandaloneDataConfig &#123;    @Bean    public DataSource dataSource() &#123;        return new EmbeddedDatabaseBuilder()            .setType(EmbeddedDatabaseType.HSQL)            .addScript(&quot;classpath:com/bank/config/sql/schema.sql&quot;)            .addScript(&quot;classpath:com/bank/config/sql/test-data.sql&quot;)            .build();    &#125;&#125;\n\n@Configuration@Profile(&quot;production&quot;)public class JndiDataConfig &#123;    @Bean(destroyMethod=&quot;&quot;)    public DataSource dataSource() throws Exception &#123;        Context ctx = new InitialContext();        return (DataSource) ctx.lookup(&quot;java:comp/env/jdbc/datasource&quot;);    &#125;&#125;\n\n@Configurationpublic class AppConfig &#123;    @Bean(&quot;dataSource&quot;)    @Profile(&quot;development&quot;) (1)    public DataSource standaloneDataSource() &#123;        return new EmbeddedDatabaseBuilder()            .setType(EmbeddedDatabaseType.HSQL)            .addScript(&quot;classpath:com/bank/config/sql/schema.sql&quot;)            .addScript(&quot;classpath:com/bank/config/sql/test-data.sql&quot;)            .build();    &#125;    @Bean(&quot;dataSource&quot;)    @Profile(&quot;production&quot;) (2)    public DataSource jndiDataSource() throws Exception &#123;        Context ctx = new InitialContext();        return (DataSource) ctx.lookup(&quot;java:comp/env/jdbc/datasource&quot;);    &#125;&#125;\n\n配置时可以使用如下逻辑符号，例如：production &amp; us-east，但是多个混用时需要加括号 production &amp; (us-east | eu-central)\n\n!：配置文件的逻辑“非”\n&amp;：配置文件的逻辑“与”\n|：配置文件的逻辑“或”\n\nxml 的配置如下：\n&lt;beans profile=&quot;development&quot;    xmlns=&quot;http://www.springframework.org/schema/beans&quot;    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;    xmlns:jdbc=&quot;http://www.springframework.org/schema/jdbc&quot;    xsi:schemaLocation=&quot;...&quot;&gt;    &lt;jdbc:embedded-database id=&quot;dataSource&quot;&gt;        &lt;jdbc:script location=&quot;classpath:com/bank/config/sql/schema.sql&quot;/&gt;        &lt;jdbc:script location=&quot;classpath:com/bank/config/sql/test-data.sql&quot;/&gt;    &lt;/jdbc:embedded-database&gt;&lt;/beans&gt;&lt;beans profile=&quot;production&quot;    xmlns=&quot;http://www.springframework.org/schema/beans&quot;    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;    xmlns:jee=&quot;http://www.springframework.org/schema/jee&quot;    xsi:schemaLocation=&quot;...&quot;&gt;    &lt;jee:jndi-lookup id=&quot;dataSource&quot; jndi-name=&quot;java:comp/env/jdbc/datasource&quot;/&gt;&lt;/beans&gt;\n\n可以在一个文件中加入多个 beans 标签：\n&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;    xmlns:jdbc=&quot;http://www.springframework.org/schema/jdbc&quot;    xmlns:jee=&quot;http://www.springframework.org/schema/jee&quot;    xsi:schemaLocation=&quot;...&quot;&gt;    &lt;!-- other bean definitions --&gt;    &lt;beans profile=&quot;development&quot;&gt;        &lt;jdbc:embedded-database id=&quot;dataSource&quot;&gt;            &lt;jdbc:script location=&quot;classpath:com/bank/config/sql/schema.sql&quot;/&gt;            &lt;jdbc:script location=&quot;classpath:com/bank/config/sql/test-data.sql&quot;/&gt;        &lt;/jdbc:embedded-database&gt;    &lt;/beans&gt;    &lt;beans profile=&quot;production&quot;&gt;        &lt;jee:jndi-lookup id=&quot;dataSource&quot; jndi-name=&quot;java:comp/env/jdbc/datasource&quot;/&gt;    &lt;/beans&gt;&lt;/beans&gt;\n\n可以通过嵌套方式表达和的含义，不支持前面描述的配置文件表达式，但是可以使用 ! 运算符取消配置文件。\n&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;xmlns:jdbc=&quot;http://www.springframework.org/schema/jdbc&quot;xmlns:jee=&quot;http://www.springframework.org/schema/jee&quot;xsi:schemaLocation=&quot;...&quot;&gt;&lt;!-- other bean definitions --&gt;    &lt;beans profile=&quot;production&quot;&gt;        &lt;beans profile=&quot;us-east&quot;&gt;            &lt;jee:jndi-lookup id=&quot;dataSource&quot; jndi-name=&quot;java:comp/env/jdbc/datasource&quot;/&gt;        &lt;/beans&gt;    &lt;/beans&gt;&lt;/beans&gt;\n\n激活 Profileapi 方式\nAnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext();ctx.getEnvironment().setActiveProfiles(&quot;profile1&quot;, &quot;profile2&quot;);ctx.register(SomeConfig.class, StandaloneDataConfig.class, JndiDataConfig.class);ctx.refresh();\n\njvm 属性配置\n-Dspring.profiles.active=&quot;profile1,profile2&quot;\n\n默认 Profile如果没有任何配置文件处于活动状态，则使用默认 profile，可以通过在 Environment 上使用 setDefaultProfiles() 或在 jvm 中使用 spring.profiles.default 属性来更改默认配置文件的名称。\n@Configuration@Profile(&quot;default&quot;)public class DefaultDataConfig &#123;    @Bean    public DataSource dataSource() &#123;        return new EmbeddedDatabaseBuilder()            .setType(EmbeddedDatabaseType.HSQL)            .addScript(&quot;classpath:com/bank/config/sql/schema.sql&quot;)            .build();    &#125;&#125;\n\nMessageSource 进行国际化ApplicationContext 接口扩展了名为 MessageSource 的接口，因此提供了国际化功能。Spring 还提供了 HierarchicalMessageSource 接口，该接口可以分层解析消息。加载 ApplicationContext 时，它将自动搜索上下文中定义的 MessageSource bean。Bean 必须具有名称 messageSource。如果找到了这样的 bean，则对先前方法的所有调用都将委派给消息源。如果找不到消息源，则 ApplicationContext 尝试查找包含同名 bean 的父对象。如果是这样，它将使用该 bean 作为 MessageSource。如果 ApplicationContext 找不到任何消息源，则实例化一个空的 DelegatingMessageSource 以便能够接受对上面定义的方法的调用。\nSpring 提供了两个 MessageSource 实现 ResourceBundleMessageSource 和 StaticMessageSource。两者都实现 HierarchicalMessageSource 以便进行嵌套消息传递。StaticMessageSource 很少使用，但提供了将消息添加到源中的编程方式。以下示例显示 ResourceBundleMessageSource：\n&lt;beans&gt;    &lt;bean id=&quot;messageSource&quot;            class=&quot;org.springframework.context.support.ResourceBundleMessageSource&quot;&gt;        &lt;property name=&quot;basenames&quot;&gt;            &lt;list&gt;                &lt;value&gt;format&lt;/value&gt;                &lt;value&gt;exceptions&lt;/value&gt;                &lt;value&gt;windows&lt;/value&gt;            &lt;/list&gt;        &lt;/property&gt;    &lt;/bean&gt;&lt;/beans&gt;\n\n# in exceptions.propertiesargument.required=The &#123;0&#125; argument is required.\n\n# in exceptions.propertiesargument.required=The &#123;0&#125; argument is required.\n\npublic static void main(String[] args) &#123;    MessageSource resources = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;);    String message = resources.getMessage(&quot;message&quot;, null, &quot;Default&quot;, null);    System.out.println(message);&#125;\n\n标准和自定义事件ApplicationContext 中的事件处理是通过 ApplicationEvent 类和 ApplicationListener 接口提供的。如果将实现 ApplicationListener 接口的 bean 部署到上下文中，则每次将 ApplicationEvent 发布到 ApplicationContext 时，都会通知该 bean。\n\n\n\nEvent\nExplanation\n\n\n\nContextRefreshedEvent\n在初始化或刷新 ApplicationContext 时发布 (例如，通过使用 ConfigurableApplicationContext 接口上的 refresh() 方法)。在这里，“已初始化”是指所有 Bean 都已加载，检测到并激活了后处理器 Bean，已预先实例化单例，并且已准备好使用 ApplicationContext 对象。只要尚未关闭上下文，只要选定的 ApplicationContext 实际上支持这种“热”刷新，就可以多次触发刷新。例如，XmlWebApplicationContext 支持热刷新，但 GenericApplicationContext 不支持。\n\n\nContextStartedEvent\n在 ConfigurableApplicationContext 界面上使用 start() 方法启动 ApplicationContext 时发布。在这里，“启动”是指所有 Lifecycle bean 都收到一个明确的启动 signal。通常，此 signal 用于在显式停止后重新启动 Bean，但也可以用于启动尚未配置为自动启动的组件 (例如，尚未在初始化时启动的组件)。\n\n\nContextStoppedEvent\n在 ConfigurableApplicationContext 接口上使用 stop() 方法停止 ApplicationContext 时发布。此处，“已停止”表示所有 Lifecycle bean 都收到一个明确的停止 signal。停止的上下文可以通过 start() 调用重新启动。\n\n\nContextClosedEvent\n在 ConfigurableApplicationContext 接口上使用 close() 方法关闭 ApplicationContext 时发布。此处，“封闭”表示所有单例 bean 都被破坏。封闭的情境到了生命的尽头。无法刷新或重新启动。\n\n\nRequestHandledEvent\n一个特定于 Web 的事件，告诉所有 Bean HTTP 请求已得到服务。请求完成后，将发布此事件。此事件仅适用于使用 Spring 的 DispatcherServlet 的 Web 应用程序。\n\n\n可以创建和发布自己的自定义事件：\npublic class BlackListEvent extends ApplicationEvent &#123;    private final String address;    private final String content;    public BlackListEvent(Object source, String address, String content) &#123;        super(source);        this.address = address;        this.content = content;    &#125;    // accessor and other methods...&#125;\n\n要发布自定义 ApplicationEvent，请在 ApplicationEventPublisher 上调用 publishEvent() 方法。通常，这是通过创建一个实现 ApplicationEventPublisherAware 的类并将其注册为 Spring bean 来完成的。\npublic class EmailService implements ApplicationEventPublisherAware &#123;    private List&lt;String&gt; blackList;    private ApplicationEventPublisher publisher;    public void setBlackList(List&lt;String&gt; blackList) &#123;        this.blackList = blackList;    &#125;    public void setApplicationEventPublisher(ApplicationEventPublisher publisher) &#123;        this.publisher = publisher;    &#125;    public void sendEmail(String address, String content) &#123;        if (blackList.contains(address)) &#123;            publisher.publishEvent(new BlackListEvent(this, address, content));            return;        &#125;        // send email...    &#125;&#125;\n\n在配置时，Spring 容器检测到 EmailService 实现 ApplicationEventPublisherAware 并自动调用 setApplicationEventPublisher()。实际上，传入的参数是 Spring 容器本身。您正在通过其 ApplicationEventPublisher 接口与应用程序上下文进行交互。要接收自定义 ApplicationEvent，可以创建一个实现 ApplicationListener 的类并将其注册为 Spring Bean。\npublic class BlackListNotifier implements ApplicationListener&lt;BlackListEvent&gt; &#123;    private String notificationAddress;    public void setNotificationAddress(String notificationAddress) &#123;        this.notificationAddress = notificationAddress;    &#125;    public void onApplicationEvent(BlackListEvent event) &#123;        // notify appropriate parties via notificationAddress...    &#125;&#125;\n\n可以使用注解来实现监听。\npublic class BlackListNotifier &#123;    private String notificationAddress;    public void setNotificationAddress(String notificationAddress) &#123;        this.notificationAddress = notificationAddress;    &#125;    @EventListener    public void processBlackListEvent(BlackListEvent event) &#123;        // notify appropriate parties via notificationAddress...    &#125;&#125;\n\n@EventListener(condition = &quot;#blEvent.content == &#x27;my-event&#x27;&quot;)public void processBlackListEvent(BlackListEvent blEvent) &#123;    // notify appropriate parties via notificationAddress...&#125;\n\n可以对特定事件进行监听。\n\n\n\nName\nLocation\nDescription\nExample\n\n\n\nEvent\nroot object\n实际的 ApplicationEvent。\n#root.event\n\n\nArguments array\nroot object\n用于调用目标的参数 (作为数组)。\n#root.args[0]\n\n\nArgument name\nevaluation context\n任何方法参数的名称。如果由于某种原因名称不可用 (例如，因为没有调试信息)，则参数名称也可以在  #a &lt;#arg&gt; 下获得，其中 #arg 代表参数索引 (从 0 开始)。\n#blEvent 或 #a0(您也可以使用 #p0 或  #p &lt;#arg&gt; 表示法作为别名)\n\n\n","categories":["Spring学习笔记"],"tags":["Spring"]}]